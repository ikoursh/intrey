{"version":3,"sources":["node_modules/@react-navigation/stack/lib/module/views/assets/back-icon.png","node_modules/@react-navigation/stack/lib/module/views/assets/back-icon-mask.png","Screens.tsx","GestureHandler.tsx","MaskedView.tsx","TouchableItem.tsx","HeaderBackButton.tsx","HeaderBackground.tsx","HeaderShownContext.tsx","memoize.tsx","HeaderSegment.tsx","CardSheet.tsx","CardAnimationContext.tsx","getInvertedMultiplier.tsx","getDistanceForDirection.tsx","Card.tsx","HeaderHeightContext.tsx","PreviousSceneContext.tsx","CardContainer.tsx","conditional.tsx","CardStyleInterpolators.tsx","HeaderStyleInterpolators.tsx","TransitionSpecs.tsx","TransitionPresets.tsx","CardStack.tsx","KeyboardManager.tsx","HeaderTitle.tsx","Header.tsx","debounce.tsx","HeaderContainer.tsx","SafeAreaProviderCompat.tsx","StackView.tsx","createStackNavigator.tsx"],"names":["module","exports","PanGestureHandler","children","GestureHandlerRootView","GestureState","Screens","require","render","this","rest","hidden","style","display","active","React","AnimatedWebScreen","Animated","shouldUseActivityState","MaybeScreenContainer","enabled","Platform","MaybeScreen","activityState","MaskedView","TouchableItem","borderless","pressColor","useForeground","TouchableNativeFeedback","background","HeaderBackButton","labelVisible","pressColorAndroid","tintColor","truncatedLabel","accessibilityLabel","label","useTheme","colors","customTintColor","ios","default","text","customPressColorAndroid","dark","handleLabelLayout","e","onLabelLayout","setInitialLabelWidth","disabled","accessible","accessibilityRole","accessibilityComponentType","accessibilityTraits","testID","delayPressIn","onPress","requestAnimationFrame","styles","hitSlop","top","right","bottom","left","backImage","Boolean","source","fadeDuration","leftLabelText","initialLabelWidth","screenLayout","titleLayout","labelElement","minWidth","onLayout","color","numberOfLines","allowFontScaling","maskElement","iconMaskContainer","iconMask","iconMaskFillerRect","renderLabel","StyleSheet","container","alignItems","flexDirection","marginVertical","marginHorizontal","opacity","fontSize","letterSpacing","labelWrapper","icon","height","width","marginLeft","marginRight","resizeMode","transform","scaleX","I18nManager","margin","iconWithLabel","flex","justifyContent","backgroundColor","alignSelf","HeaderBackground","borderBottomColor","shadowColor","border","android","elevation","shadowOpacity","shadowRadius","shadowOffset","hairlineWidth","borderBottomWidth","memoize","hasChanged","previous","dependencies","i","result","callback","getDefaultHeaderHeight","isLandscape","layout","headerHeight","HeaderSegment","props","isParentHeaderShown","getInterpolatedStyle","styleInterpolator","current","progress","next","layouts","header","screen","title","leftLabel","leftLabelLayout","headerTitleAlign","headerLeft","onGoBack","headerRight","headerBackImage","headerBackTitle","headerTruncatedBackTitle","headerPressColorAndroid","headerBackAccessibilityLabel","headerBackAllowFontScaling","headerTitleAllowFontScaling","headerTitleStyle","headerBackTitleStyle","headerLeftContainerStyle","headerRightContainerStyle","headerTitleContainerStyle","headerStyle","headerStatusBarHeight","insets","defaultHeight","customHeaderStyle","safeStyles","borderBottomEndRadius","borderBottomLeftRadius","borderBottomRightRadius","borderBottomStartRadius","borderColor","borderEndColor","borderEndWidth","borderLeftColor","borderLeftWidth","borderRadius","borderRightColor","borderRightWidth","borderStartColor","borderStartWidth","borderStyle","borderTopColor","borderTopEndRadius","borderTopLeftRadius","borderTopRightRadius","borderTopStartRadius","borderTopWidth","borderWidth","boxShadow","scene","previousTitle","backgroundStyle","leftButton","labelStyle","leftLabelStyle","setLeftLabelLayout","canGoBack","rightButton","headerTintColor","pointerEvents","zIndex","headerBackground","headerTransparent","minHeight","maxHeight","content","position","headerBackTitleVisible","Math","headerTitle","setTitleLayout","customTitleStyle","document","setFill","ref","page","card","overflow","getInvertedMultiplier","getDistanceForDirection","multiplier","useNativeDriver","velocity","onTransition","toValue","closing","spec","transitionSpec","animation","clearTimeout","gesture","undefined","isInteraction","finished","onClose","onOpen","gestureDirection","InteractionManager","nativeEvent","gestureVelocityImpact","onGestureBegin","onGestureCanceled","distance","translation","setTimeout","onGestureEnd","index","swiping","inverted","insetLeft","componentDidMount","animate","isCurrentlyMounted","componentDidUpdate","prevProps","setValue","getAnimateToValue","lastToValue","componentWillUnmount","handleEndInteraction","gestureResponseDistance","maxDeltaX","minOffsetY","minOffsetX","maxDeltaY","containerStyle","interpolatedStyle","animationContext","getCardAnimationContext","shadowStyle","handleGestureEvent","gestureEnabled","translationY","translationX","contentStyle","isTransparent","Color","CardAnimationContext","value","collapsable","overlayEnabled","absoluteFill","overlay","overlayStyle","needsOffscreenAlphaCompositing","flattenedStyle","onGestureEvent","onHandlerStateChange","handleGestureStateChange","shadowEnabled","Card","shadow","shadowHorizontal","shadowLeft","shadowRight","shadowVertical","shadowTop","shadowBottom","safeAreaInsetLeft","listener","setPointerEvents","isCurrentHeaderShown","headerMode","headerShown","previousScene","getPreviousScene","route","onTransitionEnd","onOpenRoute","onCloseRoute","onPageChangeConfirm","onPageChangeCancel","onTransitionStart","onPageChangeStart","onGestureStart","onGestureCancel","accessibilityElementsHidden","importantForAccessibility","focused","pageOverflowEnabled","mode","hasAbsoluteHeader","marginTop","HeaderHeightContext","renderScene","renderHeader","scenes","getFocusedRoute","onContentHeightChange","onHeaderHeightChange","multiply","conditional","add","condition","inputRange","outputRange","forNoAnimation","forFade","extrapolate","leftButtonStyle","rightButtonStyle","titleStyle","forSlideLeft","translateX","forSlideRight","forSlideUp","translateY","TransitionIOSSpec","config","stiffness","damping","mass","overshootClamping","restDisplacementThreshold","restSpeedThreshold","FadeInFromBottomAndroidSpec","duration","easing","Easing","FadeOutToBottomAndroidSpec","RevealFromBottomAndroidSpec","ScaleFromCenterAndroidSpec","SlideFromRightIOS","open","close","cardStyleInterpolator","cardStyle","headerStyleInterpolator","ModalSlideFromBottomIOS","FadeFromBottomAndroid","RevealFromBottomAndroid","ScaleFromCenterAndroid","scale","DefaultTransition","ModalTransition","FALLBACK_DESCRIPTOR","Object","options","getHeaderHeights","routes","descriptors","curr","safeAreaInsets","acc","getDistanceFromOptions","descriptor","getProgressFromGesture","constructor","state","headerHeights","getPreviousRoute","previousRoute","Dimensions","gestures","detachInactiveScreens","focusedRoute","focusedDescriptor","focusedOptions","focusedHeaderHeight","defaultTransitionPreset","forNoAnimationHeader","activeScreensLimit","detachPreviousScreen","isFloatHeaderAbsolute","slice","floatingHeader","key","handleLayout","isScreenActive","self","sceneForActivity","outputValue","animationEnabled","transitionConfig","nextScene","safeAreaInsetTop","safeAreaInsetRight","safeAreaInsetBottom","closingRouteKeys","cardOverlay","cardOverlayEnabled","cardShadowEnabled","getGesturesEnabled","nextRoute","oldScene","currentGesture","previousGesture","nextGesture","nextDescriptor","previousDescriptor","__memo","absolute","floating","input","TextInput","Date","force","Keyboard","clearKeyboardTimeout","handlePageChangeCancel","HeaderTitle","aria-level","fontWeight","fontFamily","o","goBack","func","timeout","debounce","navigation","StackActions","HeaderContainer","parentPreviousScene","isFocused","previousHeaderShown","isHeaderStatic","initialSafeAreaInsets","getStatusBarHeight","getBottomSpace","initialWindowSafeAreaInsets","SafeAreaProviderCompat","GestureHandlerWrapper","previousRoutes","previousDescriptors","openingRouteKeys","replacingRouteKeys","r","target","type","data","keyboardHandlingEnabled","handleGestureCancel","a","b","it","map","previousFocusedRoute","nextFocusedRoute","isAnimationEnabled","getAnimationTypeForReplace","createNavigatorFactory","defaultOptions","useNavigationBuilder","initialRouteName","screenOptions"],"mappings":"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","file":"static/js/0.bbc54f35.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAQAAABIkb+zAAAAlklEQVR4Ae3a1REDMRDG4A3VmHbcUFLigf0exn/mkxuQjmELAAAAAD5Eq5atP6+rZeuPhGz9kZCtPxKy9fs6Zuuf60CfPn369OnTp0+fPn369OnTfx36X1vh+nO6/pytL+D1BCexy+iNhFPt6/dIOEiQIEGCBAkSJEiQ8B0k+PwoQYKhP2OXAYOvRo+vD38bvwcAAACABXF8ILs1PQqpAAAAAElFTkSuQmCC\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAABVCAQAAAChx3/YAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAHdElNRQfkAQMKHDc9iQjuAAACmUlEQVRo3r3ZS2sUQRAH8M5zklwWg0K8mKBB/AIqXhTEi1cTPQe9iH4AUXBNjh79EooKgggSHyCICIIQL7NV1T2bze6EFS/xoms0ie0hs+sa9zE901U79/3R8+iu+pdSnn/VfbCAz/Um2r+XV8AO0jH9pP3vvSN2COdhGX8xInbIzNMKbv1PeEPsiLmEn2i7E+EJsSN4Az+UtjoTXpBwlG7CGnQlPCA2oFtQxZ3uRG7EBnAvjHsTOREbwB2s9bpRuZHKGCzCer9V5ELi8ehuOiIzYkejBUTYTkNkREyAV5DgdzoiE2ICuoYaUxMZEBPQdYpdCGfkzbA+rUsugDNiAnOGwJVwQipj0XlCd8IBscN0wv1GOSEmCE9qyEakREyAZ4myEqkQE+hzupydSIHE4+aUjvIQfZH6hL6QbxV9kfqEnqP1vEQPxA6YA3hReyB6IOUC3vZDdEXKBVPUG36ILkhlihbxqy+iI1KZogf4xW0zd0TWDuJD+AYWLRuyOo2P0DOxB6nM4Fv87pv4B1mdxhfY8E+0IeaIfok/OIgWEs3q97DJQyTI5xn9FBpcBFqlVDgLz6CBlu9S8SS9JlYCraKlTv2qb+QdN4FWYV0AEVkJLQH/M4kn9Sv2t0vkOxH64pt7F9f22LYLVw8D9y4sdJ40T0bgPRmVUqp+iP2MF6pWkrrrPnPdJVRB7tbCVMQNZkSkqlfKDtD+kLs/Eem0xHpGoe631cdHzIhIIiGUrSQp0XHmlEgo7xJK7loZZMiMJGlqjTVNbebCRKy5cPJsLjMn3EJZvdDUQWh+krwCReZJUHOmVaqxzrSEpnNCc0ahiWlz9ksrrLNfoSn27sgf5mCZfrIiStnB8lF8rHdYEaWU+ljQV/dW0X8Ac6zWpmDZsO8AAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDEtMDNUMTA6Mjg6NTIrMDA6MDD7fVVWAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTAxLTAzVDEwOjI4OjUyKzAwOjAwiiDt6gAAAABJRU5ErkJggg==\"","import * as React from 'react';\nimport { Animated, View, Platform, ViewProps } from 'react-native';\n\nlet Screens: typeof import('react-native-screens') | undefined;\n\ntry {\n  Screens = require('react-native-screens');\n} catch (e) {\n  // Ignore\n}\n\n// The web implementation in react-native-screens seems buggy.\n// The view doesn't become visible after coming back in some cases.\n// So we use our custom implementation.\nclass WebScreen extends React.Component<\n  ViewProps & {\n    active: number;\n    children: React.ReactNode;\n  }\n> {\n  render() {\n    const { active, style, ...rest } = this.props;\n\n    return (\n      <View\n        // @ts-expect-error: hidden exists on web, but not in React Native\n        hidden={!active}\n        style={[style, { display: active ? 'flex' : 'none' }]}\n        {...rest}\n      />\n    );\n  }\n}\n\nconst AnimatedWebScreen = Animated.createAnimatedComponent(WebScreen);\n\n// @ts-ignore\nexport const shouldUseActivityState = Screens?.shouldUseActivityState;\n\nexport const MaybeScreenContainer = ({\n  enabled,\n  ...rest\n}: ViewProps & {\n  enabled: boolean;\n  children: React.ReactNode;\n}) => {\n  if (enabled && Platform.OS !== 'web' && Screens?.screensEnabled()) {\n    return (\n      // @ts-ignore\n      <Screens.ScreenContainer enabled={enabled} {...rest} />\n    );\n  }\n\n  return <View {...rest} />;\n};\n\nexport const MaybeScreen = ({\n  enabled,\n  active,\n  ...rest\n}: ViewProps & {\n  enabled: boolean;\n  active: 0 | 1 | 2 | Animated.AnimatedInterpolation;\n  children: React.ReactNode;\n}) => {\n  if (enabled && Platform.OS === 'web') {\n    return <AnimatedWebScreen active={active} {...rest} />;\n  }\n\n  if (enabled && Screens?.screensEnabled()) {\n    if (shouldUseActivityState) {\n      return (\n        // @ts-expect-error: there was an `active` prop and no `activityState` in older version and stackPresentation was required\n        <Screens.Screen enabled={enabled} activityState={active} {...rest} />\n      );\n    } else {\n      return (\n        // @ts-expect-error: there was an `active` prop and no `activityState` in older version and stackPresentation was required\n        <Screens.Screen enabled={enabled} active={active} {...rest} />\n      );\n    }\n  }\n\n  return <View {...rest} />;\n};\n","import * as React from 'react';\nimport { View } from 'react-native';\nimport type { PanGestureHandlerProperties } from 'react-native-gesture-handler';\n\nconst Dummy: any = ({ children }: { children: React.ReactNode }) => (\n  <>{children}</>\n);\n\nexport const PanGestureHandler = Dummy as React.ComponentType<\n  PanGestureHandlerProperties\n>;\n\nexport const GestureHandlerRootView = View;\n\nexport const GestureState = {\n  UNDETERMINED: 0,\n  FAILED: 1,\n  BEGAN: 2,\n  CANCELLED: 3,\n  ACTIVE: 4,\n  END: 5,\n};\n\nexport type { PanGestureHandlerGestureEvent } from 'react-native-gesture-handler';\n","/**\n * Use a stub for MaskedView on all Platforms that don't support it.\n */\nimport type * as React from 'react';\n\ntype Props = {\n  maskElement: React.ReactElement;\n  children: React.ReactElement;\n};\n\nexport default function MaskedView({ children }: Props) {\n  return children;\n}\n","/**\n * TouchableItem provides an abstraction on top of TouchableNativeFeedback and\n * TouchableOpacity to handle platform differences.\n *\n * On Android, you can pass the props of TouchableNativeFeedback.\n * On other platforms, you can pass the props of TouchableOpacity.\n */\nimport * as React from 'react';\nimport {\n  Platform,\n  TouchableNativeFeedback,\n  TouchableOpacity,\n  View,\n  ViewProps,\n} from 'react-native';\n\nexport type Props = ViewProps & {\n  pressColor?: string;\n  disabled?: boolean;\n  borderless?: boolean;\n  delayPressIn?: number;\n  onPress?: () => void;\n  children: React.ReactNode;\n};\n\nconst ANDROID_VERSION_LOLLIPOP = 21;\n\nexport default function TouchableItem({\n  borderless = false,\n  pressColor = 'rgba(0, 0, 0, .32)',\n  style,\n  children,\n  ...rest\n}: Props) {\n  /*\n   * TouchableNativeFeedback.Ripple causes a crash on old Android versions,\n   * therefore only enable it on Android Lollipop and above.\n   *\n   * All touchables on Android should have the ripple effect according to\n   * platform design guidelines.\n   * We need to pass the background prop to specify a borderless ripple effect.\n   */\n  if (\n    Platform.OS === 'android' &&\n    Platform.Version >= ANDROID_VERSION_LOLLIPOP\n  ) {\n    return (\n      <TouchableNativeFeedback\n        {...rest}\n        useForeground={TouchableNativeFeedback.canUseNativeForeground()}\n        background={TouchableNativeFeedback.Ripple(pressColor, borderless)}\n      >\n        <View style={style}>{React.Children.only(children)}</View>\n      </TouchableNativeFeedback>\n    );\n  } else {\n    return (\n      <TouchableOpacity style={style} {...rest}>\n        {children}\n      </TouchableOpacity>\n    );\n  }\n}\n","import * as React from 'react';\nimport {\n  Animated,\n  I18nManager,\n  Image,\n  View,\n  Platform,\n  StyleSheet,\n  LayoutChangeEvent,\n} from 'react-native';\nimport { useTheme } from '@react-navigation/native';\nimport MaskedView from '../MaskedView';\nimport TouchableItem from '../TouchableItem';\nimport type { StackHeaderLeftButtonProps } from '../../types';\n\ntype Props = StackHeaderLeftButtonProps;\n\nexport default function HeaderBackButton({\n  disabled,\n  allowFontScaling,\n  backImage,\n  label,\n  labelStyle,\n  labelVisible = Platform.OS === 'ios',\n  onLabelLayout,\n  onPress,\n  pressColorAndroid: customPressColorAndroid,\n  screenLayout,\n  tintColor: customTintColor,\n  titleLayout,\n  truncatedLabel = 'Back',\n  accessibilityLabel = label && label !== 'Back' ? `${label}, back` : 'Go back',\n  style,\n}: Props) {\n  const { dark, colors } = useTheme();\n\n  const [initialLabelWidth, setInitialLabelWidth] = React.useState<\n    undefined | number\n  >(undefined);\n\n  const tintColor =\n    customTintColor !== undefined\n      ? customTintColor\n      : Platform.select({\n          ios: colors.primary,\n          default: colors.text,\n        });\n\n  const pressColorAndroid =\n    customPressColorAndroid !== undefined\n      ? customPressColorAndroid\n      : dark\n      ? 'rgba(255, 255, 255, .32)'\n      : 'rgba(0, 0, 0, .32)';\n\n  const handleLabelLayout = (e: LayoutChangeEvent) => {\n    onLabelLayout?.(e);\n\n    setInitialLabelWidth(e.nativeEvent.layout.x + e.nativeEvent.layout.width);\n  };\n\n  const shouldTruncateLabel = () => {\n    return (\n      !label ||\n      (initialLabelWidth &&\n        titleLayout &&\n        screenLayout &&\n        (screenLayout.width - titleLayout.width) / 2 < initialLabelWidth + 26)\n    );\n  };\n\n  const renderBackImage = () => {\n    if (backImage) {\n      return backImage({ tintColor });\n    } else {\n      return (\n        <Image\n          style={[\n            styles.icon,\n            Boolean(labelVisible) && styles.iconWithLabel,\n            Boolean(tintColor) && { tintColor },\n          ]}\n          source={require('../assets/back-icon.png')}\n          fadeDuration={0}\n        />\n      );\n    }\n  };\n\n  const renderLabel = () => {\n    const leftLabelText = shouldTruncateLabel() ? truncatedLabel : label;\n\n    if (!labelVisible || leftLabelText === undefined) {\n      return null;\n    }\n\n    const labelElement = (\n      <View\n        style={\n          screenLayout\n            ? // We make the button extend till the middle of the screen\n              // Otherwise it appears to cut off when translating\n              [styles.labelWrapper, { minWidth: screenLayout.width / 2 - 27 }]\n            : null\n        }\n      >\n        <Animated.Text\n          accessible={false}\n          onLayout={\n            // This measurement is used to determine if we should truncate the label when it doesn't fit\n            // Only measure it when label is not truncated because we want the measurement of full label\n            leftLabelText === label ? handleLabelLayout : undefined\n          }\n          style={[\n            styles.label,\n            tintColor ? { color: tintColor } : null,\n            labelStyle,\n          ]}\n          numberOfLines={1}\n          allowFontScaling={!!allowFontScaling}\n        >\n          {leftLabelText}\n        </Animated.Text>\n      </View>\n    );\n\n    if (backImage || Platform.OS !== 'ios') {\n      // When a custom backimage is specified, we can't mask the label\n      // Otherwise there might be weird effect due to our mask not being the same as the image\n      return labelElement;\n    }\n\n    return (\n      <MaskedView\n        maskElement={\n          <View style={styles.iconMaskContainer}>\n            <Image\n              source={require('../assets/back-icon-mask.png')}\n              style={styles.iconMask}\n            />\n            <View style={styles.iconMaskFillerRect} />\n          </View>\n        }\n      >\n        {labelElement}\n      </MaskedView>\n    );\n  };\n\n  const handlePress = () => onPress && requestAnimationFrame(onPress);\n\n  return (\n    <TouchableItem\n      disabled={disabled}\n      accessible\n      accessibilityRole=\"button\"\n      accessibilityComponentType=\"button\"\n      accessibilityLabel={accessibilityLabel}\n      accessibilityTraits=\"button\"\n      testID=\"header-back\"\n      delayPressIn={0}\n      onPress={disabled ? undefined : handlePress}\n      pressColor={pressColorAndroid}\n      style={[styles.container, disabled && styles.disabled, style]}\n      hitSlop={Platform.select({\n        ios: undefined,\n        default: { top: 16, right: 16, bottom: 16, left: 16 },\n      })}\n      borderless\n    >\n      <React.Fragment>\n        {renderBackImage()}\n        {renderLabel()}\n      </React.Fragment>\n    </TouchableItem>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    alignItems: 'center',\n    flexDirection: 'row',\n    ...Platform.select({\n      ios: null,\n      default: {\n        marginVertical: 3,\n        marginHorizontal: 11,\n      },\n    }),\n  },\n  disabled: {\n    opacity: 0.5,\n  },\n  label: {\n    fontSize: 17,\n    // Title and back label are a bit different width due to title being bold\n    // Adjusting the letterSpacing makes them coincide better\n    letterSpacing: 0.35,\n  },\n  labelWrapper: {\n    // These styles will make sure that the label doesn't fill the available space\n    // Otherwise it messes with the measurement of the label\n    flexDirection: 'row',\n    alignItems: 'flex-start',\n  },\n  icon: Platform.select({\n    ios: {\n      height: 21,\n      width: 13,\n      marginLeft: 8,\n      marginRight: 22,\n      marginVertical: 12,\n      resizeMode: 'contain',\n      transform: [{ scaleX: I18nManager.isRTL ? -1 : 1 }],\n    },\n    default: {\n      height: 24,\n      width: 24,\n      margin: 3,\n      resizeMode: 'contain',\n      transform: [{ scaleX: I18nManager.isRTL ? -1 : 1 }],\n    },\n  }),\n  iconWithLabel:\n    Platform.OS === 'ios'\n      ? {\n          marginRight: 6,\n        }\n      : {},\n  iconMaskContainer: {\n    flex: 1,\n    flexDirection: 'row',\n    justifyContent: 'center',\n  },\n  iconMaskFillerRect: {\n    flex: 1,\n    backgroundColor: '#000',\n  },\n  iconMask: {\n    height: 21,\n    width: 13,\n    marginLeft: -14.5,\n    marginVertical: 12,\n    alignSelf: 'center',\n    resizeMode: 'contain',\n    transform: [{ scaleX: I18nManager.isRTL ? -1 : 1 }],\n  },\n});\n","import * as React from 'react';\nimport {\n  Animated,\n  StyleSheet,\n  Platform,\n  ViewProps,\n  StyleProp,\n  ViewStyle,\n} from 'react-native';\nimport { useTheme } from '@react-navigation/native';\n\ntype Props = ViewProps & {\n  style?: Animated.WithAnimatedValue<StyleProp<ViewStyle>>;\n  children?: React.ReactNode;\n};\n\nexport default function HeaderBackground({ style, ...rest }: Props) {\n  const { colors } = useTheme();\n\n  return (\n    <Animated.View\n      style={[\n        styles.container,\n        {\n          backgroundColor: colors.card,\n          borderBottomColor: colors.border,\n          shadowColor: colors.border,\n        },\n        style,\n      ]}\n      {...rest}\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    ...Platform.select({\n      android: {\n        elevation: 4,\n      },\n      ios: {\n        shadowOpacity: 0.85,\n        shadowRadius: 0,\n        shadowOffset: {\n          width: 0,\n          height: StyleSheet.hairlineWidth,\n        },\n      },\n      default: {\n        borderBottomWidth: StyleSheet.hairlineWidth,\n      },\n    }),\n  },\n});\n","import * as React from 'react';\n\nconst HeaderShownContext = React.createContext(false);\n\nexport default HeaderShownContext;\n","export default function memoize<Result, Deps extends readonly any[]>(\n  callback: (...deps: Deps) => Result\n) {\n  let previous: Deps | undefined;\n  let result: Result | undefined;\n\n  return (...dependencies: Deps): Result => {\n    let hasChanged = false;\n\n    if (previous) {\n      if (previous.length !== dependencies.length) {\n        hasChanged = true;\n      } else {\n        for (let i = 0; i < previous.length; i++) {\n          if (previous[i] !== dependencies[i]) {\n            hasChanged = true;\n            break;\n          }\n        }\n      }\n    } else {\n      hasChanged = true;\n    }\n\n    previous = dependencies;\n\n    if (hasChanged || result === undefined) {\n      result = callback(...dependencies);\n    }\n\n    return result;\n  };\n}\n","import * as React from 'react';\nimport {\n  Animated,\n  View,\n  StyleSheet,\n  LayoutChangeEvent,\n  Platform,\n  ViewStyle,\n} from 'react-native';\nimport type { EdgeInsets } from 'react-native-safe-area-context';\nimport type { Route } from '@react-navigation/native';\nimport HeaderBackButton from './HeaderBackButton';\nimport HeaderBackground from './HeaderBackground';\nimport HeaderShownContext from '../../utils/HeaderShownContext';\nimport memoize from '../../utils/memoize';\nimport type {\n  Layout,\n  StackHeaderStyleInterpolator,\n  StackHeaderLeftButtonProps,\n  StackHeaderTitleProps,\n  StackHeaderOptions,\n  Scene,\n} from '../../types';\n\ntype Props = StackHeaderOptions & {\n  headerTitle: (props: StackHeaderTitleProps) => React.ReactNode;\n  layout: Layout;\n  insets: EdgeInsets;\n  onGoBack?: () => void;\n  title?: string;\n  leftLabel?: string;\n  scene: Scene<Route<string>>;\n  styleInterpolator: StackHeaderStyleInterpolator;\n};\n\nconst warnIfHeaderStylesDefined = (styles: Record<string, any>) => {\n  Object.keys(styles).forEach((styleProp) => {\n    const value = styles[styleProp];\n\n    if (styleProp === 'position' && value === 'absolute') {\n      console.warn(\n        \"position: 'absolute' is not supported on headerStyle. If you would like to render content under the header, use the 'headerTransparent' navigationOption.\"\n      );\n    } else if (value !== undefined) {\n      console.warn(\n        `${styleProp} was given a value of ${value}, this has no effect on headerStyle.`\n      );\n    }\n  });\n};\n\nexport const getDefaultHeaderHeight = (\n  layout: Layout,\n  statusBarHeight: number\n): number => {\n  const isLandscape = layout.width > layout.height;\n\n  let headerHeight;\n\n  if (Platform.OS === 'ios') {\n    if (isLandscape && !Platform.isPad) {\n      headerHeight = 32;\n    } else {\n      headerHeight = 44;\n    }\n  } else if (Platform.OS === 'android') {\n    headerHeight = 56;\n  } else {\n    headerHeight = 64;\n  }\n\n  return headerHeight + statusBarHeight;\n};\n\nexport default function HeaderSegment(props: Props) {\n  const [leftLabelLayout, setLeftLabelLayout] = React.useState<\n    Layout | undefined\n  >(undefined);\n\n  const [titleLayout, setTitleLayout] = React.useState<Layout | undefined>(\n    undefined\n  );\n\n  const isParentHeaderShown = React.useContext(HeaderShownContext);\n\n  const handleTitleLayout = (e: LayoutChangeEvent) => {\n    const { height, width } = e.nativeEvent.layout;\n\n    setTitleLayout((titleLayout) => {\n      if (\n        titleLayout &&\n        height === titleLayout.height &&\n        width === titleLayout.width\n      ) {\n        return titleLayout;\n      }\n\n      return { height, width };\n    });\n  };\n\n  const handleLeftLabelLayout = (e: LayoutChangeEvent) => {\n    const { height, width } = e.nativeEvent.layout;\n\n    if (\n      leftLabelLayout &&\n      height === leftLabelLayout.height &&\n      width === leftLabelLayout.width\n    ) {\n      return;\n    }\n\n    setLeftLabelLayout({ height, width });\n  };\n\n  const getInterpolatedStyle = memoize(\n    (\n      styleInterpolator: StackHeaderStyleInterpolator,\n      layout: Layout,\n      current: Animated.AnimatedInterpolation,\n      next: Animated.AnimatedInterpolation | undefined,\n      titleLayout: Layout | undefined,\n      leftLabelLayout: Layout | undefined,\n      headerHeight: number\n    ) =>\n      styleInterpolator({\n        current: { progress: current },\n        next: next && { progress: next },\n        layouts: {\n          header: {\n            height: headerHeight,\n            width: layout.width,\n          },\n          screen: layout,\n          title: titleLayout,\n          leftLabel: leftLabelLayout,\n        },\n      })\n  );\n\n  const {\n    scene,\n    layout,\n    insets,\n    title: currentTitle,\n    leftLabel: previousTitle,\n    onGoBack,\n    headerTitle,\n    headerTitleAlign = Platform.select({\n      ios: 'center',\n      default: 'left',\n    }),\n    headerLeft: left = onGoBack\n      ? (props: StackHeaderLeftButtonProps) => <HeaderBackButton {...props} />\n      : undefined,\n    headerTransparent,\n    headerTintColor,\n    headerBackground,\n    headerRight: right,\n    headerBackImage: backImage,\n    headerBackTitle: leftLabel,\n    headerBackTitleVisible,\n    headerTruncatedBackTitle: truncatedLabel,\n    headerPressColorAndroid: pressColorAndroid,\n    headerBackAccessibilityLabel: backAccessibilityLabel,\n    headerBackAllowFontScaling: backAllowFontScaling,\n    headerTitleAllowFontScaling: titleAllowFontScaling,\n    headerTitleStyle: customTitleStyle,\n    headerBackTitleStyle: customLeftLabelStyle,\n    headerLeftContainerStyle: leftContainerStyle,\n    headerRightContainerStyle: rightContainerStyle,\n    headerTitleContainerStyle: titleContainerStyle,\n    headerStyle: customHeaderStyle,\n    headerStatusBarHeight = isParentHeaderShown ? 0 : insets.top,\n    styleInterpolator,\n  } = props;\n\n  const defaultHeight = getDefaultHeaderHeight(layout, headerStatusBarHeight);\n\n  const {\n    height = defaultHeight,\n    minHeight,\n    maxHeight,\n    backgroundColor,\n    borderBottomColor,\n    borderBottomEndRadius,\n    borderBottomLeftRadius,\n    borderBottomRightRadius,\n    borderBottomStartRadius,\n    borderBottomWidth,\n    borderColor,\n    borderEndColor,\n    borderEndWidth,\n    borderLeftColor,\n    borderLeftWidth,\n    borderRadius,\n    borderRightColor,\n    borderRightWidth,\n    borderStartColor,\n    borderStartWidth,\n    borderStyle,\n    borderTopColor,\n    borderTopEndRadius,\n    borderTopLeftRadius,\n    borderTopRightRadius,\n    borderTopStartRadius,\n    borderTopWidth,\n    borderWidth,\n    // @ts-expect-error: web support for shadow\n    boxShadow,\n    elevation,\n    shadowColor,\n    shadowOffset,\n    shadowOpacity,\n    shadowRadius,\n    opacity,\n    transform,\n    ...unsafeStyles\n  } = StyleSheet.flatten(customHeaderStyle || {}) as ViewStyle;\n\n  if (process.env.NODE_ENV !== 'production') {\n    warnIfHeaderStylesDefined(unsafeStyles);\n  }\n\n  const safeStyles: ViewStyle = {\n    backgroundColor,\n    borderBottomColor,\n    borderBottomEndRadius,\n    borderBottomLeftRadius,\n    borderBottomRightRadius,\n    borderBottomStartRadius,\n    borderBottomWidth,\n    borderColor,\n    borderEndColor,\n    borderEndWidth,\n    borderLeftColor,\n    borderLeftWidth,\n    borderRadius,\n    borderRightColor,\n    borderRightWidth,\n    borderStartColor,\n    borderStartWidth,\n    borderStyle,\n    borderTopColor,\n    borderTopEndRadius,\n    borderTopLeftRadius,\n    borderTopRightRadius,\n    borderTopStartRadius,\n    borderTopWidth,\n    borderWidth,\n    // @ts-expect-error: boxShadow is only for Web\n    boxShadow,\n    elevation,\n    shadowColor,\n    shadowOffset,\n    shadowOpacity,\n    shadowRadius,\n    opacity,\n    transform,\n  };\n\n  // Setting a property to undefined triggers default style\n  // So we need to filter them out\n  // Users can use `null` instead\n  for (const styleProp in safeStyles) {\n    // @ts-expect-error: typescript wrongly complains that styleProp cannot be used to index safeStyles\n    if (safeStyles[styleProp] === undefined) {\n      // @ts-expect-error\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete safeStyles[styleProp];\n    }\n  }\n\n  const {\n    titleStyle,\n    leftButtonStyle,\n    leftLabelStyle,\n    rightButtonStyle,\n    backgroundStyle,\n  } = getInterpolatedStyle(\n    styleInterpolator,\n    layout,\n    scene.progress.current,\n    scene.progress.next,\n    titleLayout,\n    previousTitle ? leftLabelLayout : undefined,\n    typeof height === 'number' ? height : defaultHeight\n  );\n\n  const leftButton = left\n    ? left({\n        backImage,\n        pressColorAndroid,\n        accessibilityLabel: backAccessibilityLabel,\n        allowFontScaling: backAllowFontScaling,\n        onPress: onGoBack,\n        labelVisible: headerBackTitleVisible,\n        label: leftLabel !== undefined ? leftLabel : previousTitle,\n        truncatedLabel,\n        labelStyle: [leftLabelStyle, customLeftLabelStyle],\n        onLabelLayout: handleLeftLabelLayout,\n        screenLayout: layout,\n        titleLayout,\n        tintColor: headerTintColor,\n        canGoBack: Boolean(onGoBack),\n      })\n    : null;\n\n  const rightButton = right ? right({ tintColor: headerTintColor }) : null;\n\n  return (\n    <React.Fragment>\n      <Animated.View\n        pointerEvents=\"box-none\"\n        style={[StyleSheet.absoluteFill, { zIndex: 0 }, backgroundStyle]}\n      >\n        {headerBackground ? (\n          headerBackground({ style: safeStyles })\n        ) : headerTransparent ? null : (\n          <HeaderBackground style={safeStyles} />\n        )}\n      </Animated.View>\n      <Animated.View\n        pointerEvents=\"box-none\"\n        style={[{ height, minHeight, maxHeight, opacity, transform }]}\n      >\n        <View pointerEvents=\"none\" style={{ height: headerStatusBarHeight }} />\n        <View pointerEvents=\"box-none\" style={styles.content}>\n          {leftButton ? (\n            <Animated.View\n              pointerEvents=\"box-none\"\n              style={[\n                styles.left,\n                { left: insets.left },\n                leftButtonStyle,\n                leftContainerStyle,\n              ]}\n            >\n              {leftButton}\n            </Animated.View>\n          ) : null}\n          <Animated.View\n            pointerEvents=\"box-none\"\n            style={[\n              headerTitleAlign === 'left'\n                ? {\n                    position: 'absolute',\n                    left: (leftButton ? 72 : 16) + insets.left,\n                    right: (rightButton ? 72 : 16) + insets.right,\n                  }\n                : {\n                    marginHorizontal:\n                      (leftButton ? 32 : 16) +\n                      (leftButton && headerBackTitleVisible !== false\n                        ? 40\n                        : 0) +\n                      Math.max(insets.left, insets.right),\n                  },\n              titleStyle,\n              titleContainerStyle,\n            ]}\n          >\n            {headerTitle({\n              children: currentTitle,\n              onLayout: handleTitleLayout,\n              allowFontScaling: titleAllowFontScaling,\n              tintColor: headerTintColor,\n              style: customTitleStyle,\n            })}\n          </Animated.View>\n          {rightButton ? (\n            <Animated.View\n              pointerEvents=\"box-none\"\n              style={[\n                styles.right,\n                { right: insets.right },\n                rightButtonStyle,\n                rightContainerStyle,\n              ]}\n            >\n              {rightButton}\n            </Animated.View>\n          ) : null}\n        </View>\n      </Animated.View>\n    </React.Fragment>\n  );\n}\n\nconst styles = StyleSheet.create({\n  content: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  left: {\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    bottom: 0,\n    justifyContent: 'center',\n    alignItems: 'flex-start',\n  },\n  right: {\n    position: 'absolute',\n    right: 0,\n    top: 0,\n    bottom: 0,\n    justifyContent: 'center',\n    alignItems: 'flex-end',\n  },\n});\n","import * as React from 'react';\nimport { View, ViewProps, StyleSheet } from 'react-native';\n\ntype Props = ViewProps & {\n  enabled: boolean;\n  layout: { width: number; height: number };\n  children: React.ReactNode;\n};\n\n// This component will render a page which overflows the screen\n// if the container fills the body by comparing the size\n// This lets the document.body handle scrolling of the content\n// It's necessary for mobile browsers to be able to hide address bar on scroll\nexport default React.forwardRef<View, Props>(function CardSheet(\n  { enabled, layout, style, ...rest },\n  ref\n) {\n  const [fill, setFill] = React.useState(false);\n\n  React.useEffect(() => {\n    if (typeof document === 'undefined' || !document.body) {\n      // Only run when DOM is available\n      return;\n    }\n\n    const width = document.body.clientWidth;\n    const height = document.body.clientHeight;\n\n    setFill(width === layout.width && height === layout.height);\n  }, [layout.height, layout.width]);\n\n  return (\n    <View\n      {...rest}\n      ref={ref}\n      style={[enabled && fill ? styles.page : styles.card, style]}\n    />\n  );\n});\n\nconst styles = StyleSheet.create({\n  page: {\n    minHeight: '100%',\n  },\n  card: {\n    flex: 1,\n    overflow: 'hidden',\n  },\n});\n","import * as React from 'react';\nimport type { StackCardInterpolationProps } from '../types';\n\nexport default React.createContext<StackCardInterpolationProps | undefined>(\n  undefined\n);\n","import { I18nManager } from 'react-native';\nimport type { GestureDirection } from '../types';\n\nexport default function getInvertedMultiplier(\n  gestureDirection: GestureDirection\n): 1 | -1 {\n  switch (gestureDirection) {\n    case 'vertical':\n      return 1;\n    case 'vertical-inverted':\n      return -1;\n    case 'horizontal':\n      return I18nManager.isRTL ? -1 : 1;\n    case 'horizontal-inverted':\n      return I18nManager.isRTL ? 1 : -1;\n  }\n}\n","import getInvertedMultiplier from './getInvertedMultiplier';\nimport type { GestureDirection, Layout } from '../types';\n\nexport default function getDistanceForDirection(\n  layout: Layout,\n  gestureDirection: GestureDirection\n): number {\n  const multiplier = getInvertedMultiplier(gestureDirection);\n\n  switch (gestureDirection) {\n    case 'vertical':\n    case 'vertical-inverted':\n      return layout.height * multiplier;\n    case 'horizontal':\n    case 'horizontal-inverted':\n      return layout.width * multiplier;\n  }\n}\n","import * as React from 'react';\nimport {\n  Animated,\n  View,\n  StyleSheet,\n  ViewProps,\n  StyleProp,\n  ViewStyle,\n  Platform,\n  InteractionManager,\n} from 'react-native';\nimport type { EdgeInsets } from 'react-native-safe-area-context';\nimport Color from 'color';\n\nimport CardSheet from './CardSheet';\nimport {\n  PanGestureHandler,\n  GestureState,\n  PanGestureHandlerGestureEvent,\n} from '../GestureHandler';\nimport CardAnimationContext from '../../utils/CardAnimationContext';\nimport getDistanceForDirection from '../../utils/getDistanceForDirection';\nimport getInvertedMultiplier from '../../utils/getInvertedMultiplier';\nimport memoize from '../../utils/memoize';\nimport type {\n  TransitionSpec,\n  StackCardStyleInterpolator,\n  GestureDirection,\n  Layout,\n} from '../../types';\n\ntype Props = ViewProps & {\n  index: number;\n  closing: boolean;\n  next?: Animated.AnimatedInterpolation;\n  current: Animated.AnimatedInterpolation;\n  gesture: Animated.Value;\n  layout: Layout;\n  insets: EdgeInsets;\n  pageOverflowEnabled: boolean;\n  gestureDirection: GestureDirection;\n  onOpen: () => void;\n  onClose: () => void;\n  onTransition?: (props: { closing: boolean; gesture: boolean }) => void;\n  onGestureBegin?: () => void;\n  onGestureCanceled?: () => void;\n  onGestureEnd?: () => void;\n  children: React.ReactNode;\n  overlay: (props: {\n    style: Animated.WithAnimatedValue<StyleProp<ViewStyle>>;\n  }) => React.ReactNode;\n  overlayEnabled: boolean;\n  shadowEnabled: boolean;\n  gestureEnabled: boolean;\n  gestureResponseDistance?: {\n    vertical?: number;\n    horizontal?: number;\n  };\n  gestureVelocityImpact: number;\n  transitionSpec: {\n    open: TransitionSpec;\n    close: TransitionSpec;\n  };\n  styleInterpolator: StackCardStyleInterpolator;\n  containerStyle?: StyleProp<ViewStyle>;\n  contentStyle?: StyleProp<ViewStyle>;\n};\n\nconst GESTURE_VELOCITY_IMPACT = 0.3;\n\nconst TRUE = 1;\nconst FALSE = 0;\n\n/**\n * The distance of touch start from the edge of the screen where the gesture will be recognized\n */\nconst GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 50;\nconst GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\n\nconst useNativeDriver = Platform.OS !== 'web';\n\nconst hasOpacityStyle = (style: any) => {\n  if (style) {\n    const flattenedStyle = StyleSheet.flatten(style);\n    return flattenedStyle.opacity != null;\n  }\n\n  return false;\n};\n\nexport default class Card extends React.Component<Props> {\n  static defaultProps = {\n    overlayEnabled: Platform.OS !== 'ios',\n    shadowEnabled: true,\n    gestureEnabled: true,\n    gestureVelocityImpact: GESTURE_VELOCITY_IMPACT,\n    overlay: ({\n      style,\n    }: {\n      style: Animated.WithAnimatedValue<StyleProp<ViewStyle>>;\n    }) =>\n      style ? (\n        <Animated.View pointerEvents=\"none\" style={[styles.overlay, style]} />\n      ) : null,\n  };\n\n  componentDidMount() {\n    this.animate({ closing: this.props.closing });\n    this.isCurrentlyMounted = true;\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    const { layout, gestureDirection, closing } = this.props;\n    const { width, height } = layout;\n\n    if (width !== prevProps.layout.width) {\n      this.layout.width.setValue(width);\n    }\n\n    if (height !== prevProps.layout.height) {\n      this.layout.height.setValue(height);\n    }\n\n    if (gestureDirection !== prevProps.gestureDirection) {\n      this.inverted.setValue(getInvertedMultiplier(gestureDirection));\n    }\n\n    const toValue = this.getAnimateToValue(this.props);\n\n    if (\n      this.getAnimateToValue(prevProps) !== toValue ||\n      this.lastToValue !== toValue\n    ) {\n      // We need to trigger the animation when route was closed\n      // Thr route might have been closed by a `POP` action or by a gesture\n      // When route was closed due to a gesture, the animation would've happened already\n      // It's still important to trigger the animation so that `onClose` is called\n      // If `onClose` is not called, cleanup step won't be performed for gestures\n      this.animate({ closing });\n    }\n  }\n\n  componentWillUnmount() {\n    this.isCurrentlyMounted = false;\n    this.handleEndInteraction();\n  }\n\n  private isCurrentlyMounted = false;\n\n  private isClosing = new Animated.Value(FALSE);\n\n  private inverted = new Animated.Value(\n    getInvertedMultiplier(this.props.gestureDirection)\n  );\n\n  private layout = {\n    width: new Animated.Value(this.props.layout.width),\n    height: new Animated.Value(this.props.layout.height),\n  };\n\n  private isSwiping = new Animated.Value(FALSE);\n\n  private interactionHandle: number | undefined;\n\n  private pendingGestureCallback: number | undefined;\n\n  private lastToValue: number | undefined;\n\n  private animate = ({\n    closing,\n    velocity,\n  }: {\n    closing: boolean;\n    velocity?: number;\n  }) => {\n    const {\n      gesture,\n      transitionSpec,\n      onOpen,\n      onClose,\n      onTransition,\n    } = this.props;\n\n    const toValue = this.getAnimateToValue({\n      ...this.props,\n      closing,\n    });\n\n    this.lastToValue = toValue;\n\n    const spec = closing ? transitionSpec.close : transitionSpec.open;\n\n    const animation =\n      spec.animation === 'spring' ? Animated.spring : Animated.timing;\n\n    this.setPointerEventsEnabled(!closing);\n    this.handleStartInteraction();\n\n    clearTimeout(this.pendingGestureCallback);\n\n    onTransition?.({ closing, gesture: velocity !== undefined });\n    animation(gesture, {\n      ...spec.config,\n      velocity,\n      toValue,\n      useNativeDriver,\n      isInteraction: false,\n    }).start(({ finished }) => {\n      this.handleEndInteraction();\n\n      clearTimeout(this.pendingGestureCallback);\n\n      if (finished) {\n        if (closing) {\n          onClose();\n        } else {\n          onOpen();\n        }\n\n        if (this.isCurrentlyMounted) {\n          // Make sure to re-open screen if it wasn't removed\n          this.forceUpdate();\n        }\n      }\n    });\n  };\n\n  private getAnimateToValue = ({\n    closing,\n    layout,\n    gestureDirection,\n  }: {\n    closing?: boolean;\n    layout: Layout;\n    gestureDirection: GestureDirection;\n  }) => {\n    if (!closing) {\n      return 0;\n    }\n\n    return getDistanceForDirection(layout, gestureDirection);\n  };\n\n  private setPointerEventsEnabled = (enabled: boolean) => {\n    const pointerEvents = enabled ? 'box-none' : 'none';\n\n    this.contentRef.current?.setNativeProps({ pointerEvents });\n  };\n\n  private handleStartInteraction = () => {\n    if (this.interactionHandle === undefined) {\n      this.interactionHandle = InteractionManager.createInteractionHandle();\n    }\n  };\n\n  private handleEndInteraction = () => {\n    if (this.interactionHandle !== undefined) {\n      InteractionManager.clearInteractionHandle(this.interactionHandle);\n      this.interactionHandle = undefined;\n    }\n  };\n\n  private handleGestureStateChange = ({\n    nativeEvent,\n  }: PanGestureHandlerGestureEvent) => {\n    const {\n      layout,\n      onClose,\n      onGestureBegin,\n      onGestureCanceled,\n      onGestureEnd,\n      gestureDirection,\n      gestureVelocityImpact,\n    } = this.props;\n\n    switch (nativeEvent.state) {\n      case GestureState.BEGAN:\n        this.isSwiping.setValue(TRUE);\n        this.handleStartInteraction();\n        onGestureBegin?.();\n        break;\n      case GestureState.CANCELLED: {\n        this.isSwiping.setValue(FALSE);\n        this.handleEndInteraction();\n\n        const velocity =\n          gestureDirection === 'vertical' ||\n          gestureDirection === 'vertical-inverted'\n            ? nativeEvent.velocityY\n            : nativeEvent.velocityX;\n\n        this.animate({ closing: this.props.closing, velocity });\n\n        onGestureCanceled?.();\n        break;\n      }\n      case GestureState.END: {\n        this.isSwiping.setValue(FALSE);\n\n        let distance;\n        let translation;\n        let velocity;\n\n        if (\n          gestureDirection === 'vertical' ||\n          gestureDirection === 'vertical-inverted'\n        ) {\n          distance = layout.height;\n          translation = nativeEvent.translationY;\n          velocity = nativeEvent.velocityY;\n        } else {\n          distance = layout.width;\n          translation = nativeEvent.translationX;\n          velocity = nativeEvent.velocityX;\n        }\n\n        const closing =\n          (translation + velocity * gestureVelocityImpact) *\n            getInvertedMultiplier(gestureDirection) >\n          distance / 2\n            ? velocity !== 0 || translation !== 0\n            : this.props.closing;\n\n        this.animate({ closing, velocity });\n\n        if (closing) {\n          // We call onClose with a delay to make sure that the animation has already started\n          // This will make sure that the state update caused by this doesn't affect start of animation\n          this.pendingGestureCallback = (setTimeout(() => {\n            onClose();\n\n            // Trigger an update after we dispatch the action to remove the screen\n            // This will make sure that we check if the screen didn't get removed so we can cancel the animation\n            this.forceUpdate();\n          }, 32) as any) as number;\n        }\n\n        onGestureEnd?.();\n        break;\n      }\n    }\n  };\n\n  // Memoize this to avoid extra work on re-render\n  private getInterpolatedStyle = memoize(\n    (\n      styleInterpolator: StackCardStyleInterpolator,\n      index: number,\n      current: Animated.AnimatedInterpolation,\n      next: Animated.AnimatedInterpolation | undefined,\n      layout: Layout,\n      insetTop: number,\n      insetRight: number,\n      insetBottom: number,\n      insetLeft: number\n    ) =>\n      styleInterpolator({\n        index,\n        current: { progress: current },\n        next: next && { progress: next },\n        closing: this.isClosing,\n        swiping: this.isSwiping,\n        inverted: this.inverted,\n        layouts: {\n          screen: layout,\n        },\n        insets: {\n          top: insetTop,\n          right: insetRight,\n          bottom: insetBottom,\n          left: insetLeft,\n        },\n      })\n  );\n\n  // Keep track of the animation context when deps changes.\n  private getCardAnimationContext = memoize(\n    (\n      index: number,\n      current: Animated.AnimatedInterpolation,\n      next: Animated.AnimatedInterpolation | undefined,\n      layout: Layout,\n      insetTop: number,\n      insetRight: number,\n      insetBottom: number,\n      insetLeft: number\n    ) => ({\n      index,\n      current: { progress: current },\n      next: next && { progress: next },\n      closing: this.isClosing,\n      swiping: this.isSwiping,\n      inverted: this.inverted,\n      layouts: {\n        screen: layout,\n      },\n      insets: {\n        top: insetTop,\n        right: insetRight,\n        bottom: insetBottom,\n        left: insetLeft,\n      },\n    })\n  );\n\n  private gestureActivationCriteria() {\n    const { layout, gestureDirection, gestureResponseDistance } = this.props;\n\n    const distance =\n      gestureDirection === 'vertical' ||\n      gestureDirection === 'vertical-inverted'\n        ? gestureResponseDistance?.vertical !== undefined\n          ? gestureResponseDistance.vertical\n          : GESTURE_RESPONSE_DISTANCE_VERTICAL\n        : gestureResponseDistance?.horizontal !== undefined\n        ? gestureResponseDistance.horizontal\n        : GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n\n    if (gestureDirection === 'vertical') {\n      return {\n        maxDeltaX: 15,\n        minOffsetY: 5,\n        hitSlop: { bottom: -layout.height + distance },\n      };\n    } else if (gestureDirection === 'vertical-inverted') {\n      return {\n        maxDeltaX: 15,\n        minOffsetY: -5,\n        hitSlop: { top: -layout.height + distance },\n      };\n    } else {\n      const hitSlop = -layout.width + distance;\n      const invertedMultiplier = getInvertedMultiplier(gestureDirection);\n\n      if (invertedMultiplier === 1) {\n        return {\n          minOffsetX: 5,\n          maxDeltaY: 20,\n          hitSlop: { right: hitSlop },\n        };\n      } else {\n        return {\n          minOffsetX: -5,\n          maxDeltaY: 20,\n          hitSlop: { left: hitSlop },\n        };\n      }\n    }\n  }\n\n  private contentRef = React.createRef<View>();\n\n  render() {\n    const {\n      styleInterpolator,\n      index,\n      current,\n      gesture,\n      next,\n      layout,\n      insets,\n      overlay,\n      overlayEnabled,\n      shadowEnabled,\n      gestureEnabled,\n      gestureDirection,\n      pageOverflowEnabled,\n      children,\n      containerStyle: customContainerStyle,\n      contentStyle,\n      ...rest\n    } = this.props;\n\n    const interpolatedStyle = this.getInterpolatedStyle(\n      styleInterpolator,\n      index,\n      current,\n      next,\n      layout,\n      insets.top,\n      insets.right,\n      insets.bottom,\n      insets.left\n    );\n\n    const animationContext = this.getCardAnimationContext(\n      index,\n      current,\n      next,\n      layout,\n      insets.top,\n      insets.right,\n      insets.bottom,\n      insets.left\n    );\n\n    const {\n      containerStyle,\n      cardStyle,\n      overlayStyle,\n      shadowStyle,\n    } = interpolatedStyle;\n\n    const handleGestureEvent = gestureEnabled\n      ? Animated.event(\n          [\n            {\n              nativeEvent:\n                gestureDirection === 'vertical' ||\n                gestureDirection === 'vertical-inverted'\n                  ? { translationY: gesture }\n                  : { translationX: gesture },\n            },\n          ],\n          { useNativeDriver }\n        )\n      : undefined;\n\n    const { backgroundColor } = StyleSheet.flatten(contentStyle || {});\n    const isTransparent =\n      typeof backgroundColor === 'string'\n        ? Color(backgroundColor).alpha() === 0\n        : false;\n\n    return (\n      <CardAnimationContext.Provider value={animationContext}>\n        <Animated.View\n          style={{\n            // This is a dummy style that doesn't actually change anything visually.\n            // Animated needs the animated value to be used somewhere, otherwise things don't update properly.\n            // If we disable animations and hide header, it could end up making the value unused.\n            // So we have this dummy style that will always be used regardless of what else changed.\n            opacity: current,\n          }}\n          // Make sure that this view isn't removed. If this view is removed, our style with animated value won't apply\n          collapsable={false}\n        />\n        <View pointerEvents=\"box-none\" {...rest}>\n          {overlayEnabled ? (\n            <View pointerEvents=\"box-none\" style={StyleSheet.absoluteFill}>\n              {overlay({ style: overlayStyle })}\n            </View>\n          ) : null}\n          <Animated.View\n            needsOffscreenAlphaCompositing={hasOpacityStyle(containerStyle)}\n            style={[styles.container, containerStyle, customContainerStyle]}\n            pointerEvents=\"box-none\"\n          >\n            <PanGestureHandler\n              enabled={layout.width !== 0 && gestureEnabled}\n              onGestureEvent={handleGestureEvent}\n              onHandlerStateChange={this.handleGestureStateChange}\n              {...this.gestureActivationCriteria()}\n            >\n              <Animated.View style={[styles.container, cardStyle]}>\n                {shadowEnabled && shadowStyle && !isTransparent ? (\n                  <Animated.View\n                    style={[\n                      styles.shadow,\n                      gestureDirection === 'horizontal'\n                        ? [styles.shadowHorizontal, styles.shadowLeft]\n                        : gestureDirection === 'horizontal-inverted'\n                        ? [styles.shadowHorizontal, styles.shadowRight]\n                        : gestureDirection === 'vertical'\n                        ? [styles.shadowVertical, styles.shadowTop]\n                        : [styles.shadowVertical, styles.shadowBottom],\n                      { backgroundColor },\n                      shadowStyle,\n                    ]}\n                    pointerEvents=\"none\"\n                  />\n                ) : null}\n                <CardSheet\n                  ref={this.contentRef}\n                  enabled={pageOverflowEnabled}\n                  layout={layout}\n                  style={contentStyle}\n                >\n                  {children}\n                </CardSheet>\n              </Animated.View>\n            </PanGestureHandler>\n          </Animated.View>\n        </View>\n      </CardAnimationContext.Provider>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  overlay: {\n    flex: 1,\n    backgroundColor: '#000',\n  },\n  shadow: {\n    position: 'absolute',\n    shadowRadius: 5,\n    shadowColor: '#000',\n    shadowOpacity: 0.3,\n  },\n  shadowHorizontal: {\n    top: 0,\n    bottom: 0,\n    width: 3,\n    shadowOffset: { width: -1, height: 1 },\n  },\n  shadowLeft: {\n    left: 0,\n  },\n  shadowRight: {\n    right: 0,\n  },\n  shadowVertical: {\n    left: 0,\n    right: 0,\n    height: 3,\n    shadowOffset: { width: 1, height: -1 },\n  },\n  shadowTop: {\n    top: 0,\n  },\n  shadowBottom: {\n    bottom: 0,\n  },\n});\n","import * as React from 'react';\n\nexport default React.createContext<number | undefined>(undefined);\n","import * as React from 'react';\nimport type { Route } from '@react-navigation/native';\nimport type { Scene } from '../types';\n\nconst PreviousSceneContext = React.createContext<\n  Scene<Route<string>> | undefined\n>(undefined);\n\nexport default PreviousSceneContext;\n","import * as React from 'react';\nimport { Animated, View, StyleSheet, StyleProp, ViewStyle } from 'react-native';\nimport { Route, useTheme } from '@react-navigation/native';\nimport type { Props as HeaderContainerProps } from '../Header/HeaderContainer';\nimport Card from './Card';\nimport HeaderHeightContext from '../../utils/HeaderHeightContext';\nimport HeaderShownContext from '../../utils/HeaderShownContext';\nimport PreviousSceneContext from '../../utils/PreviousSceneContext';\nimport type {\n  Scene,\n  Layout,\n  StackHeaderMode,\n  StackCardMode,\n  TransitionPreset,\n} from '../../types';\n\ntype Props = TransitionPreset & {\n  index: number;\n  active: boolean;\n  focused: boolean;\n  closing: boolean;\n  layout: Layout;\n  gesture: Animated.Value;\n  scene: Scene<Route<string>>;\n  safeAreaInsetTop: number;\n  safeAreaInsetRight: number;\n  safeAreaInsetBottom: number;\n  safeAreaInsetLeft: number;\n  cardOverlay?: (props: {\n    style: Animated.WithAnimatedValue<StyleProp<ViewStyle>>;\n  }) => React.ReactNode;\n  cardOverlayEnabled?: boolean;\n  cardShadowEnabled?: boolean;\n  cardStyle?: StyleProp<ViewStyle>;\n  getPreviousScene: (props: {\n    route: Route<string>;\n  }) => Scene<Route<string>> | undefined;\n  getFocusedRoute: () => Route<string>;\n  renderHeader: (props: HeaderContainerProps) => React.ReactNode;\n  renderScene: (props: { route: Route<string> }) => React.ReactNode;\n  onOpenRoute: (props: { route: Route<string> }) => void;\n  onCloseRoute: (props: { route: Route<string> }) => void;\n  onTransitionStart?: (\n    props: { route: Route<string> },\n    closing: boolean\n  ) => void;\n  onTransitionEnd?: (props: { route: Route<string> }, closing: boolean) => void;\n  onPageChangeStart?: () => void;\n  onPageChangeConfirm?: (force: boolean) => void;\n  onPageChangeCancel?: () => void;\n  onGestureStart?: (props: { route: Route<string> }) => void;\n  onGestureEnd?: (props: { route: Route<string> }) => void;\n  onGestureCancel?: (props: { route: Route<string> }) => void;\n  gestureEnabled?: boolean;\n  gestureResponseDistance?: {\n    vertical?: number;\n    horizontal?: number;\n  };\n  gestureVelocityImpact?: number;\n  mode: StackCardMode;\n  headerMode: StackHeaderMode;\n  headerShown: boolean;\n  hasAbsoluteHeader: boolean;\n  headerHeight: number;\n  onHeaderHeightChange: (props: {\n    route: Route<string>;\n    height: number;\n  }) => void;\n  isParentHeaderShown: boolean;\n};\n\nconst EPSILON = 0.1;\n\nfunction CardContainer({\n  active,\n  cardOverlay,\n  cardOverlayEnabled,\n  cardShadowEnabled,\n  cardStyle,\n  cardStyleInterpolator,\n  closing,\n  gesture,\n  focused,\n  gestureDirection,\n  gestureEnabled,\n  gestureResponseDistance,\n  gestureVelocityImpact,\n  getPreviousScene,\n  getFocusedRoute,\n  mode,\n  headerMode,\n  headerShown,\n  headerStyleInterpolator,\n  hasAbsoluteHeader,\n  headerHeight,\n  onHeaderHeightChange,\n  isParentHeaderShown,\n  index,\n  layout,\n  onCloseRoute,\n  onOpenRoute,\n  onPageChangeCancel,\n  onPageChangeConfirm,\n  onPageChangeStart,\n  onGestureCancel,\n  onGestureEnd,\n  onGestureStart,\n  onTransitionEnd,\n  onTransitionStart,\n  renderHeader,\n  renderScene,\n  safeAreaInsetBottom,\n  safeAreaInsetLeft,\n  safeAreaInsetRight,\n  safeAreaInsetTop,\n  scene,\n  transitionSpec,\n}: Props) {\n  const handleOpen = () => {\n    const { route } = scene;\n\n    onTransitionEnd?.({ route }, false);\n    onOpenRoute({ route });\n  };\n\n  const handleClose = () => {\n    const { route } = scene;\n\n    onTransitionEnd?.({ route }, true);\n    onCloseRoute({ route });\n  };\n\n  const handleGestureBegin = () => {\n    const { route } = scene;\n\n    onPageChangeStart?.();\n    onGestureStart?.({ route });\n  };\n\n  const handleGestureCanceled = () => {\n    const { route } = scene;\n\n    onPageChangeCancel?.();\n    onGestureCancel?.({ route });\n  };\n\n  const handleGestureEnd = () => {\n    const { route } = scene;\n\n    onGestureEnd?.({ route });\n  };\n\n  const handleTransition = ({\n    closing,\n    gesture,\n  }: {\n    closing: boolean;\n    gesture: boolean;\n  }) => {\n    const { route } = scene;\n\n    if (!gesture) {\n      onPageChangeConfirm?.(true);\n    } else if (active && closing) {\n      onPageChangeConfirm?.(false);\n    } else {\n      onPageChangeCancel?.();\n    }\n\n    onTransitionStart?.({ route }, closing);\n  };\n\n  const insets = {\n    top: safeAreaInsetTop,\n    right: safeAreaInsetRight,\n    bottom: safeAreaInsetBottom,\n    left: safeAreaInsetLeft,\n  };\n\n  const { colors } = useTheme();\n\n  const [pointerEvents, setPointerEvents] = React.useState<'box-none' | 'none'>(\n    'box-none'\n  );\n\n  React.useEffect(() => {\n    // @ts-expect-error: AnimatedInterpolation optionally has addListener, but the type defs don't think so\n    const listener = scene.progress.next?.addListener?.(\n      ({ value }: { value: number }) => {\n        setPointerEvents(value <= EPSILON ? 'box-none' : 'none');\n      }\n    );\n\n    return () => {\n      if (listener) {\n        // @ts-expect-error: AnimatedInterpolation optionally has removedListener, but the type defs don't think so\n        scene.progress.next?.removeListener?.(listener);\n      }\n    };\n  }, [pointerEvents, scene.progress.next]);\n\n  const isCurrentHeaderShown = headerMode !== 'none' && headerShown !== false;\n  const previousScene = getPreviousScene({ route: scene.route });\n\n  return (\n    <Card\n      index={index}\n      gestureDirection={gestureDirection}\n      layout={layout}\n      insets={insets}\n      gesture={gesture}\n      current={scene.progress.current}\n      next={scene.progress.next}\n      closing={closing}\n      onOpen={handleOpen}\n      onClose={handleClose}\n      overlay={cardOverlay}\n      overlayEnabled={cardOverlayEnabled}\n      shadowEnabled={cardShadowEnabled}\n      onTransition={handleTransition}\n      onGestureBegin={handleGestureBegin}\n      onGestureCanceled={handleGestureCanceled}\n      onGestureEnd={handleGestureEnd}\n      gestureEnabled={gestureEnabled}\n      gestureResponseDistance={gestureResponseDistance}\n      gestureVelocityImpact={gestureVelocityImpact}\n      transitionSpec={transitionSpec}\n      styleInterpolator={cardStyleInterpolator}\n      accessibilityElementsHidden={!focused}\n      importantForAccessibility={focused ? 'auto' : 'no-hide-descendants'}\n      pointerEvents={active ? 'box-none' : pointerEvents}\n      pageOverflowEnabled={headerMode === 'screen' && mode === 'card'}\n      containerStyle={hasAbsoluteHeader ? { marginTop: headerHeight } : null}\n      contentStyle={[{ backgroundColor: colors.background }, cardStyle]}\n      style={[\n        {\n          // This is necessary to avoid unfocused larger pages increasing scroll area\n          // The issue can be seen on the web when a smaller screen is pushed over a larger one\n          overflow: active ? undefined : 'hidden',\n        },\n        StyleSheet.absoluteFill,\n      ]}\n    >\n      <View style={styles.container}>\n        <View style={styles.scene}>\n          <PreviousSceneContext.Provider value={previousScene}>\n            <HeaderShownContext.Provider\n              value={isParentHeaderShown || isCurrentHeaderShown}\n            >\n              <HeaderHeightContext.Provider value={headerHeight}>\n                {renderScene({ route: scene.route })}\n              </HeaderHeightContext.Provider>\n            </HeaderShownContext.Provider>\n          </PreviousSceneContext.Provider>\n        </View>\n        {headerMode === 'screen'\n          ? renderHeader({\n              mode: 'screen',\n              layout,\n              insets,\n              scenes: [previousScene, scene],\n              getPreviousScene,\n              getFocusedRoute,\n              gestureDirection,\n              styleInterpolator: headerStyleInterpolator,\n              onContentHeightChange: onHeaderHeightChange,\n            })\n          : null}\n      </View>\n    </Card>\n  );\n}\n\nexport default React.memo(CardContainer);\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'column-reverse',\n  },\n  scene: {\n    flex: 1,\n  },\n});\n","import { Animated } from 'react-native';\n\nconst { add, multiply } = Animated;\n\n/**\n * Use an Animated Node based on a condition. Similar to Reanimated's `cond`.\n *\n * @param condition Animated Node representing the condition, must be 0 or 1, 1 means `true`, 0 means `false`\n * @param main Animated Node to use if the condition is `true`\n * @param fallback Animated Node to use if the condition is `false`\n */\nexport default function conditional(\n  condition: Animated.AnimatedInterpolation,\n  main: Animated.AnimatedInterpolation,\n  fallback: Animated.AnimatedInterpolation\n) {\n  // To implement this behavior, we multiply the main node with the condition.\n  // So if condition is 0, result will be 0, and if condition is 1, result will be main node.\n  // Then we multiple reverse of the condition (0 if condition is 1) with the fallback.\n  // So if condition is 0, result will be fallback node, and if condition is 1, result will be 0,\n  // This way, one of them will always be 0, and other one will be the value we need.\n  // In the end we add them both together, 0 + value we need = value we need\n  return add(\n    multiply(condition, main),\n    multiply(\n      condition.interpolate({\n        inputRange: [0, 1],\n        outputRange: [1, 0],\n      }),\n      fallback\n    )\n  );\n}\n","import { Animated } from 'react-native';\nimport { isIphoneX } from 'react-native-iphone-x-helper';\nimport conditional from '../utils/conditional';\nimport type {\n  StackCardInterpolationProps,\n  StackCardInterpolatedStyle,\n} from '../types';\n\nconst { add, multiply } = Animated;\n\n/**\n * Standard iOS-style slide in from the right.\n */\nexport function forHorizontalIOS({\n  current,\n  next,\n  inverted,\n  layouts: { screen },\n}: StackCardInterpolationProps): StackCardInterpolatedStyle {\n  const translateFocused = multiply(\n    current.progress.interpolate({\n      inputRange: [0, 1],\n      outputRange: [screen.width, 0],\n      extrapolate: 'clamp',\n    }),\n    inverted\n  );\n\n  const translateUnfocused = next\n    ? multiply(\n        next.progress.interpolate({\n          inputRange: [0, 1],\n          outputRange: [0, screen.width * -0.3],\n          extrapolate: 'clamp',\n        }),\n        inverted\n      )\n    : 0;\n\n  const overlayOpacity = current.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [0, 0.07],\n    extrapolate: 'clamp',\n  });\n\n  const shadowOpacity = current.progress.interpolate({\n    inputRange: [0, 1],\n    outputRange: [0, 0.3],\n    extrapolate: 'clamp',\n  });\n\n  return {\n    cardStyle: {\n      transform: [\n        // Translation for the animation of the current card\n        { translateX: translateFocused },\n        // Translation for the animation of the card on top of this\n        { translateX: translateUnfocused },\n      ],\n    },\n    overlayStyle: { opacity: overlayOpacity },\n    shadowStyle: { shadowOpacity },\n  };\n}\n\n/**\n * Standard iOS-style slide in from the bottom (used for modals).\n */\nexport function forVerticalIOS({\n  current,\n  inverted,\n  layouts: { screen },\n}: StackCardInterpolationProps): StackCardInterpolatedStyle {\n  const translateY = multiply(\n    current.progress.interpolate({\n      inputRange: [0, 1],\n      outputRange: [screen.height, 0],\n      extrapolate: 'clamp',\n    }),\n    inverted\n  );\n\n  return {\n    cardStyle: {\n      transform: [\n        // Translation for the animation of the current card\n        { translateY },\n      ],\n    },\n  };\n}\n\n/**\n * Standard iOS-style modal animation in iOS 13.\n */\nexport function forModalPresentationIOS({\n  index,\n  current,\n  next,\n  inverted,\n  layouts: { screen },\n  insets,\n}: StackCardInterpolationProps): StackCardInterpolatedStyle {\n  const isLandscape = screen.width > screen.height;\n  const topOffset = isLandscape ? 0 : 10;\n  const statusBarHeight = insets.top;\n  const aspectRatio = screen.height / screen.width;\n\n  const progress = add(\n    current.progress.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 1],\n      extrapolate: 'clamp',\n    }),\n    next\n      ? next.progress.interpolate({\n          inputRange: [0, 1],\n          outputRange: [0, 1],\n          extrapolate: 'clamp',\n        })\n      : 0\n  );\n\n  const translateY = multiply(\n    progress.interpolate({\n      inputRange: [0, 1, 2],\n      outputRange: [\n        screen.height,\n        index === 0 ? 0 : topOffset,\n        (index === 0 ? statusBarHeight : 0) - topOffset * aspectRatio,\n      ],\n    }),\n    inverted\n  );\n\n  const overlayOpacity = progress.interpolate({\n    inputRange: [0, 1, 1.0001, 2],\n    outputRange: [0, 0.3, 1, 1],\n  });\n\n  const scale = isLandscape\n    ? 1\n    : progress.interpolate({\n        inputRange: [0, 1, 2],\n        outputRange: [\n          1,\n          1,\n          screen.width ? 1 - (topOffset * 2) / screen.width : 1,\n        ],\n      });\n\n  const borderRadius = isLandscape\n    ? 0\n    : index === 0\n    ? progress.interpolate({\n        inputRange: [0, 1, 1.0001, 2],\n        outputRange: [0, 0, isIphoneX() ? 38 : 0, 10],\n      })\n    : 10;\n\n  return {\n    cardStyle: {\n      overflow: 'hidden',\n      borderTopLeftRadius: borderRadius,\n      borderTopRightRadius: borderRadius,\n      marginTop: index === 0 ? 0 : statusBarHeight,\n      marginBottom: index === 0 ? 0 : topOffset,\n      transform: [{ translateY }, { scale }],\n    },\n    overlayStyle: { opacity: overlayOpacity },\n  };\n}\n\n/**\n * Standard Android-style fade in from the bottom for Android Oreo.\n */\nexport function forFadeFromBottomAndroid({\n  current,\n  inverted,\n  layouts: { screen },\n  closing,\n}: StackCardInterpolationProps): StackCardInterpolatedStyle {\n  const translateY = multiply(\n    current.progress.interpolate({\n      inputRange: [0, 1],\n      outputRange: [screen.height * 0.08, 0],\n      extrapolate: 'clamp',\n    }),\n    inverted\n  );\n\n  const opacity = conditional(\n    closing,\n    current.progress,\n    current.progress.interpolate({\n      inputRange: [0, 0.5, 0.9, 1],\n      outputRange: [0, 0.25, 0.7, 1],\n    })\n  );\n\n  return {\n    cardStyle: {\n      opacity,\n      transform: [{ translateY }],\n    },\n  };\n}\n\n/**\n * Standard Android-style reveal from the bottom for Android Pie.\n */\nexport function forRevealFromBottomAndroid({\n  current,\n  next,\n  inverted,\n  layouts: { screen },\n}: StackCardInterpolationProps): StackCardInterpolatedStyle {\n  const containerTranslateY = multiply(\n    current.progress.interpolate({\n      inputRange: [0, 1],\n      outputRange: [screen.height, 0],\n      extrapolate: 'clamp',\n    }),\n    inverted\n  );\n\n  const cardTranslateYFocused = multiply(\n    current.progress.interpolate({\n      inputRange: [0, 1],\n      outputRange: [screen.height * (95.9 / 100) * -1, 0],\n      extrapolate: 'clamp',\n    }),\n    inverted\n  );\n\n  const cardTranslateYUnfocused = next\n    ? multiply(\n        next.progress.interpolate({\n          inputRange: [0, 1],\n          outputRange: [0, screen.height * (2 / 100) * -1],\n          extrapolate: 'clamp',\n        }),\n        inverted\n      )\n    : 0;\n\n  const overlayOpacity = current.progress.interpolate({\n    inputRange: [0, 0.36, 1],\n    outputRange: [0, 0.1, 0.1],\n    extrapolate: 'clamp',\n  });\n\n  return {\n    containerStyle: {\n      overflow: 'hidden',\n      transform: [{ translateY: containerTranslateY }],\n    },\n    cardStyle: {\n      transform: [\n        { translateY: cardTranslateYFocused },\n        { translateY: cardTranslateYUnfocused },\n      ],\n    },\n    overlayStyle: { opacity: overlayOpacity },\n  };\n}\n\n/**\n * Standard Android-style reveal from the bottom for Android Q.\n */\nexport function forScaleFromCenterAndroid({\n  current,\n  next,\n  closing,\n}: StackCardInterpolationProps): StackCardInterpolatedStyle {\n  const progress = add(\n    current.progress.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 1],\n      extrapolate: 'clamp',\n    }),\n    next\n      ? next.progress.interpolate({\n          inputRange: [0, 1],\n          outputRange: [0, 1],\n          extrapolate: 'clamp',\n        })\n      : 0\n  );\n\n  const opacity = progress.interpolate({\n    inputRange: [0, 0.75, 0.875, 1, 1.0825, 1.2075, 2],\n    outputRange: [0, 0, 1, 1, 1, 1, 0],\n  });\n\n  const scale = conditional(\n    closing,\n    current.progress.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0.9, 1],\n      extrapolate: 'clamp',\n    }),\n    progress.interpolate({\n      inputRange: [0, 1, 2],\n      outputRange: [0.85, 1, 1.1],\n    })\n  );\n\n  return {\n    containerStyle: {\n      opacity,\n      transform: [{ scale }],\n    },\n  };\n}\n\nexport function forNoAnimation(): StackCardInterpolatedStyle {\n  return {};\n}\n","import { Animated, I18nManager } from 'react-native';\nimport type {\n  StackHeaderInterpolationProps,\n  StackHeaderInterpolatedStyle,\n} from '../types';\n\nconst { add } = Animated;\n\n/**\n * Standard UIKit style animation for the header where the title fades into the back button label.\n */\nexport function forUIKit({\n  current,\n  next,\n  layouts,\n}: StackHeaderInterpolationProps): StackHeaderInterpolatedStyle {\n  const defaultOffset = 100;\n  const leftSpacing = 27;\n\n  // The title and back button title should cross-fade to each other\n  // When screen is fully open, the title should be in center, and back title should be on left\n  // When screen is closing, the previous title will animate to back title's position\n  // And back title will animate to title's position\n  // We achieve this by calculating the offsets needed to translate title to back title's position and vice-versa\n  const leftLabelOffset = layouts.leftLabel\n    ? (layouts.screen.width - layouts.leftLabel.width) / 2 - leftSpacing\n    : defaultOffset;\n  const titleLeftOffset = layouts.title\n    ? (layouts.screen.width - layouts.title.width) / 2 - leftSpacing\n    : defaultOffset;\n\n  // When the current title is animating to right, it is centered in the right half of screen in middle of transition\n  // The back title also animates in from this position\n  const rightOffset = layouts.screen.width / 4;\n\n  const progress = add(\n    current.progress.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 1],\n      extrapolate: 'clamp',\n    }),\n    next\n      ? next.progress.interpolate({\n          inputRange: [0, 1],\n          outputRange: [0, 1],\n          extrapolate: 'clamp',\n        })\n      : 0\n  );\n\n  return {\n    leftButtonStyle: {\n      opacity: progress.interpolate({\n        inputRange: [0.3, 1, 1.5],\n        outputRange: [0, 1, 0],\n      }),\n    },\n    leftLabelStyle: {\n      transform: [\n        {\n          translateX: progress.interpolate({\n            inputRange: [0, 1, 2],\n            outputRange: I18nManager.isRTL\n              ? [-rightOffset, 0, leftLabelOffset]\n              : [leftLabelOffset, 0, -rightOffset],\n          }),\n        },\n      ],\n    },\n    rightButtonStyle: {\n      opacity: progress.interpolate({\n        inputRange: [0.3, 1, 1.5],\n        outputRange: [0, 1, 0],\n      }),\n    },\n    titleStyle: {\n      opacity: progress.interpolate({\n        inputRange: [0, 0.4, 1, 1.5],\n        outputRange: [0, 0.1, 1, 0],\n      }),\n      transform: [\n        {\n          translateX: progress.interpolate({\n            inputRange: [0.5, 1, 2],\n            outputRange: I18nManager.isRTL\n              ? [-titleLeftOffset, 0, rightOffset]\n              : [rightOffset, 0, -titleLeftOffset],\n          }),\n        },\n      ],\n    },\n    backgroundStyle: {\n      transform: [\n        {\n          translateX: progress.interpolate({\n            inputRange: [0, 1, 2],\n            outputRange: I18nManager.isRTL\n              ? [-layouts.screen.width, 0, layouts.screen.width]\n              : [layouts.screen.width, 0, -layouts.screen.width],\n          }),\n        },\n      ],\n    },\n  };\n}\n\n/**\n * Simple fade animation for the header elements.\n */\nexport function forFade({\n  current,\n  next,\n}: StackHeaderInterpolationProps): StackHeaderInterpolatedStyle {\n  const progress = add(\n    current.progress.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 1],\n      extrapolate: 'clamp',\n    }),\n    next\n      ? next.progress.interpolate({\n          inputRange: [0, 1],\n          outputRange: [0, 1],\n          extrapolate: 'clamp',\n        })\n      : 0\n  );\n\n  const opacity = progress.interpolate({\n    inputRange: [0, 1, 2],\n    outputRange: [0, 1, 0],\n  });\n\n  return {\n    leftButtonStyle: { opacity },\n    rightButtonStyle: { opacity },\n    titleStyle: { opacity },\n    backgroundStyle: {\n      opacity: progress.interpolate({\n        inputRange: [0, 1, 1.9, 2],\n        outputRange: [0, 1, 1, 0],\n      }),\n    },\n  };\n}\n\n/**\n * Simple translate animation to translate the header to left.\n */\nexport function forSlideLeft({\n  current,\n  next,\n  layouts: { screen },\n}: StackHeaderInterpolationProps): StackHeaderInterpolatedStyle {\n  const progress = add(\n    current.progress.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 1],\n      extrapolate: 'clamp',\n    }),\n    next\n      ? next.progress.interpolate({\n          inputRange: [0, 1],\n          outputRange: [0, 1],\n          extrapolate: 'clamp',\n        })\n      : 0\n  );\n\n  const translateX = progress.interpolate({\n    inputRange: [0, 1, 2],\n    outputRange: I18nManager.isRTL\n      ? [-screen.width, 0, screen.width]\n      : [screen.width, 0, -screen.width],\n  });\n\n  const transform = [{ translateX }];\n\n  return {\n    leftButtonStyle: { transform },\n    rightButtonStyle: { transform },\n    titleStyle: { transform },\n    backgroundStyle: { transform },\n  };\n}\n\n/**\n * Simple translate animation to translate the header to right.\n */\nexport function forSlideRight({\n  current,\n  next,\n  layouts: { screen },\n}: StackHeaderInterpolationProps): StackHeaderInterpolatedStyle {\n  const progress = add(\n    current.progress.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 1],\n      extrapolate: 'clamp',\n    }),\n    next\n      ? next.progress.interpolate({\n          inputRange: [0, 1],\n          outputRange: [0, 1],\n          extrapolate: 'clamp',\n        })\n      : 0\n  );\n\n  const translateX = progress.interpolate({\n    inputRange: [0, 1, 2],\n    outputRange: I18nManager.isRTL\n      ? [screen.width, 0, -screen.width]\n      : [-screen.width, 0, screen.width],\n  });\n\n  const transform = [{ translateX }];\n\n  return {\n    leftButtonStyle: { transform },\n    rightButtonStyle: { transform },\n    titleStyle: { transform },\n    backgroundStyle: { transform },\n  };\n}\n\n/**\n * Simple translate animation to translate the header to slide up.\n */\nexport function forSlideUp({\n  current,\n  next,\n  layouts: { header },\n}: StackHeaderInterpolationProps): StackHeaderInterpolatedStyle {\n  const progress = add(\n    current.progress.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 1],\n      extrapolate: 'clamp',\n    }),\n    next\n      ? next.progress.interpolate({\n          inputRange: [0, 1],\n          outputRange: [0, 1],\n          extrapolate: 'clamp',\n        })\n      : 0\n  );\n\n  const translateY = progress.interpolate({\n    inputRange: [0, 1, 2],\n    outputRange: [-header.height, 0, -header.height],\n  });\n\n  const transform = [{ translateY }];\n\n  return {\n    leftButtonStyle: { transform },\n    rightButtonStyle: { transform },\n    titleStyle: { transform },\n    backgroundStyle: { transform },\n  };\n}\n\nexport function forNoAnimation(): StackHeaderInterpolatedStyle {\n  return {};\n}\n","import { Easing } from 'react-native';\nimport type { TransitionSpec } from '../types';\n\n/**\n * Exact values from UINavigationController's animation configuration.\n */\nexport const TransitionIOSSpec: TransitionSpec = {\n  animation: 'spring',\n  config: {\n    stiffness: 1000,\n    damping: 500,\n    mass: 3,\n    overshootClamping: true,\n    restDisplacementThreshold: 10,\n    restSpeedThreshold: 10,\n  },\n};\n\n/**\n * Configuration for activity open animation from Android Nougat.\n * See http://aosp.opersys.com/xref/android-7.1.2_r37/xref/frameworks/base/core/res/res/anim/activity_open_enter.xml\n */\nexport const FadeInFromBottomAndroidSpec: TransitionSpec = {\n  animation: 'timing',\n  config: {\n    duration: 350,\n    easing: Easing.out(Easing.poly(5)),\n  },\n};\n\n/**\n * Configuration for activity close animation from Android Nougat.\n * See http://aosp.opersys.com/xref/android-7.1.2_r37/xref/frameworks/base/core/res/res/anim/activity_close_exit.xml\n */\nexport const FadeOutToBottomAndroidSpec: TransitionSpec = {\n  animation: 'timing',\n  config: {\n    duration: 150,\n    easing: Easing.in(Easing.linear),\n  },\n};\n\n/**\n * Approximate configuration for activity open animation from Android Pie.\n * See http://aosp.opersys.com/xref/android-9.0.0_r47/xref/frameworks/base/core/res/res/anim/activity_open_enter.xml\n */\nexport const RevealFromBottomAndroidSpec: TransitionSpec = {\n  animation: 'timing',\n  config: {\n    duration: 425,\n    // This is super rough approximation of the path used for the curve by android\n    // See http://aosp.opersys.com/xref/android-9.0.0_r47/xref/frameworks/base/core/res/res/interpolator/fast_out_extra_slow_in.xml\n    easing: Easing.bezier(0.35, 0.45, 0, 1),\n  },\n};\n\n/**\n * Approximate configuration for activity open animation from Android Q.\n * See http://aosp.opersys.com/xref/android-10.0.0_r2/xref/frameworks/base/core/res/res/anim/activity_open_enter.xml\n */\nexport const ScaleFromCenterAndroidSpec: TransitionSpec = {\n  animation: 'timing',\n  config: {\n    duration: 400,\n    // This is super rough approximation of the path used for the curve by android\n    // See http://aosp.opersys.com/xref/android-10.0.0_r2/xref/frameworks/base/core/res/res/interpolator/fast_out_extra_slow_in.xml\n    easing: Easing.bezier(0.35, 0.45, 0, 1),\n  },\n};\n","import { Platform } from 'react-native';\nimport {\n  forHorizontalIOS,\n  forVerticalIOS,\n  forScaleFromCenterAndroid,\n  forRevealFromBottomAndroid,\n  forFadeFromBottomAndroid,\n  forModalPresentationIOS,\n} from './CardStyleInterpolators';\nimport { forFade } from './HeaderStyleInterpolators';\nimport {\n  TransitionIOSSpec,\n  ScaleFromCenterAndroidSpec,\n  RevealFromBottomAndroidSpec,\n  FadeOutToBottomAndroidSpec,\n  FadeInFromBottomAndroidSpec,\n} from './TransitionSpecs';\nimport type { TransitionPreset } from '../types';\n\nconst ANDROID_VERSION_PIE = 28;\nconst ANDROID_VERSION_10 = 29;\n\n/**\n * Standard iOS navigation transition.\n */\nexport const SlideFromRightIOS: TransitionPreset = {\n  gestureDirection: 'horizontal',\n  transitionSpec: {\n    open: TransitionIOSSpec,\n    close: TransitionIOSSpec,\n  },\n  cardStyleInterpolator: forHorizontalIOS,\n  headerStyleInterpolator: forFade,\n};\n\n/**\n * Standard iOS navigation transition for modals.\n */\nexport const ModalSlideFromBottomIOS: TransitionPreset = {\n  gestureDirection: 'vertical',\n  transitionSpec: {\n    open: TransitionIOSSpec,\n    close: TransitionIOSSpec,\n  },\n  cardStyleInterpolator: forVerticalIOS,\n  headerStyleInterpolator: forFade,\n};\n\n/**\n * Standard iOS modal presentation style (introduced in iOS 13).\n */\nexport const ModalPresentationIOS: TransitionPreset = {\n  gestureDirection: 'vertical',\n  transitionSpec: {\n    open: TransitionIOSSpec,\n    close: TransitionIOSSpec,\n  },\n  cardStyleInterpolator: forModalPresentationIOS,\n  headerStyleInterpolator: forFade,\n};\n\n/**\n * Standard Android navigation transition when opening or closing an Activity on Android < 9 (Oreo).\n */\nexport const FadeFromBottomAndroid: TransitionPreset = {\n  gestureDirection: 'vertical',\n  transitionSpec: {\n    open: FadeInFromBottomAndroidSpec,\n    close: FadeOutToBottomAndroidSpec,\n  },\n  cardStyleInterpolator: forFadeFromBottomAndroid,\n  headerStyleInterpolator: forFade,\n};\n\n/**\n * Standard Android navigation transition when opening or closing an Activity on Android 9 (Pie).\n */\nexport const RevealFromBottomAndroid: TransitionPreset = {\n  gestureDirection: 'vertical',\n  transitionSpec: {\n    open: RevealFromBottomAndroidSpec,\n    close: RevealFromBottomAndroidSpec,\n  },\n  cardStyleInterpolator: forRevealFromBottomAndroid,\n  headerStyleInterpolator: forFade,\n};\n\n/**\n * Standard Android navigation transition when opening or closing an Activity on Android 10 (Q).\n */\nexport const ScaleFromCenterAndroid: TransitionPreset = {\n  gestureDirection: 'horizontal',\n  transitionSpec: {\n    open: ScaleFromCenterAndroidSpec,\n    close: ScaleFromCenterAndroidSpec,\n  },\n  cardStyleInterpolator: forScaleFromCenterAndroid,\n  headerStyleInterpolator: forFade,\n};\n\n/**\n * Default navigation transition for the current platform.\n */\nexport const DefaultTransition = Platform.select({\n  ios: SlideFromRightIOS,\n  android:\n    Platform.Version >= ANDROID_VERSION_10\n      ? ScaleFromCenterAndroid\n      : Platform.Version >= ANDROID_VERSION_PIE\n      ? RevealFromBottomAndroid\n      : FadeFromBottomAndroid,\n  default: ScaleFromCenterAndroid,\n});\n\n/**\n * Default modal transition for the current platform.\n */\nexport const ModalTransition = Platform.select({\n  ios: ModalSlideFromBottomIOS,\n  default: DefaultTransition,\n});\n","import * as React from 'react';\nimport {\n  Animated,\n  StyleSheet,\n  LayoutChangeEvent,\n  Dimensions,\n  Platform,\n} from 'react-native';\nimport type { EdgeInsets } from 'react-native-safe-area-context';\nimport type {\n  ParamListBase,\n  Route,\n  StackNavigationState,\n} from '@react-navigation/native';\n\nimport {\n  MaybeScreenContainer,\n  MaybeScreen,\n  shouldUseActivityState,\n} from '../Screens';\nimport { getDefaultHeaderHeight } from '../Header/HeaderSegment';\nimport type { Props as HeaderContainerProps } from '../Header/HeaderContainer';\nimport CardContainer from './CardContainer';\nimport {\n  DefaultTransition,\n  ModalTransition,\n} from '../../TransitionConfigs/TransitionPresets';\nimport { forNoAnimation as forNoAnimationHeader } from '../../TransitionConfigs/HeaderStyleInterpolators';\nimport { forNoAnimation as forNoAnimationCard } from '../../TransitionConfigs/CardStyleInterpolators';\nimport getDistanceForDirection from '../../utils/getDistanceForDirection';\nimport type {\n  Layout,\n  StackHeaderMode,\n  StackCardMode,\n  Scene,\n  StackDescriptorMap,\n  StackNavigationOptions,\n  StackDescriptor,\n} from '../../types';\n\ntype GestureValues = {\n  [key: string]: Animated.Value;\n};\n\ntype Props = {\n  mode: StackCardMode;\n  insets: EdgeInsets;\n  state: StackNavigationState<ParamListBase>;\n  descriptors: StackDescriptorMap;\n  routes: Route<string>[];\n  openingRouteKeys: string[];\n  closingRouteKeys: string[];\n  onOpenRoute: (props: { route: Route<string> }) => void;\n  onCloseRoute: (props: { route: Route<string> }) => void;\n  getPreviousRoute: (props: {\n    route: Route<string>;\n  }) => Route<string> | undefined;\n  getGesturesEnabled: (props: { route: Route<string> }) => boolean;\n  renderHeader: (props: HeaderContainerProps) => React.ReactNode;\n  renderScene: (props: { route: Route<string> }) => React.ReactNode;\n  headerMode: StackHeaderMode;\n  isParentHeaderShown: boolean;\n  onTransitionStart: (\n    props: { route: Route<string> },\n    closing: boolean\n  ) => void;\n  onTransitionEnd: (props: { route: Route<string> }, closing: boolean) => void;\n  onPageChangeStart?: () => void;\n  onPageChangeConfirm?: (force: boolean) => void;\n  onPageChangeCancel?: () => void;\n  onGestureStart?: (props: { route: Route<string> }) => void;\n  onGestureEnd?: (props: { route: Route<string> }) => void;\n  onGestureCancel?: (props: { route: Route<string> }) => void;\n  detachInactiveScreens?: boolean;\n};\n\ntype State = {\n  routes: Route<string>[];\n  descriptors: StackDescriptorMap;\n  scenes: Scene<Route<string>>[];\n  gestures: GestureValues;\n  layout: Layout;\n  headerHeights: Record<string, number>;\n};\n\nconst EPSILON = 0.01;\n\nconst STATE_INACTIVE = 0;\nconst STATE_TRANSITIONING_OR_BELOW_TOP = 1;\nconst STATE_ON_TOP = 2;\n\nconst FALLBACK_DESCRIPTOR = Object.freeze({ options: {} });\n\nconst getHeaderHeights = (\n  routes: Route<string>[],\n  insets: EdgeInsets,\n  isParentHeaderShown: boolean,\n  descriptors: StackDescriptorMap,\n  layout: Layout,\n  previous: Record<string, number>\n) => {\n  return routes.reduce<Record<string, number>>((acc, curr) => {\n    const { options = {} } = descriptors[curr.key] || {};\n    const style: any = StyleSheet.flatten(options.headerStyle || {});\n\n    const height =\n      typeof style.height === 'number' ? style.height : previous[curr.key];\n\n    const safeAreaInsets = {\n      ...insets,\n      ...options.safeAreaInsets,\n    };\n\n    const {\n      headerStatusBarHeight = isParentHeaderShown ? 0 : safeAreaInsets.top,\n    } = options;\n\n    acc[curr.key] =\n      typeof height === 'number'\n        ? height\n        : getDefaultHeaderHeight(layout, headerStatusBarHeight);\n\n    return acc;\n  }, {});\n};\n\nconst getDistanceFromOptions = (\n  mode: StackCardMode,\n  layout: Layout,\n  descriptor?: StackDescriptor\n) => {\n  const {\n    gestureDirection = mode === 'modal'\n      ? ModalTransition.gestureDirection\n      : DefaultTransition.gestureDirection,\n  } = descriptor?.options || {};\n\n  return getDistanceForDirection(layout, gestureDirection);\n};\n\nconst getProgressFromGesture = (\n  mode: StackCardMode,\n  gesture: Animated.Value,\n  layout: Layout,\n  descriptor?: StackDescriptor\n) => {\n  const distance = getDistanceFromOptions(\n    mode,\n    {\n      // Make sure that we have a non-zero distance, otherwise there will be incorrect progress\n      // This causes blank screen on web if it was previously inside container with display: none\n      width: Math.max(1, layout.width),\n      height: Math.max(1, layout.height),\n    },\n    descriptor\n  );\n\n  if (distance > 0) {\n    return gesture.interpolate({\n      inputRange: [0, distance],\n      outputRange: [1, 0],\n    });\n  }\n\n  return gesture.interpolate({\n    inputRange: [distance, 0],\n    outputRange: [0, 1],\n  });\n};\n\nexport default class CardStack extends React.Component<Props, State> {\n  static getDerivedStateFromProps(props: Props, state: State) {\n    if (\n      props.routes === state.routes &&\n      props.descriptors === state.descriptors\n    ) {\n      return null;\n    }\n\n    const gestures = props.routes.reduce<GestureValues>((acc, curr) => {\n      const descriptor = props.descriptors[curr.key];\n      const { animationEnabled } = descriptor?.options || {};\n\n      acc[curr.key] =\n        state.gestures[curr.key] ||\n        new Animated.Value(\n          props.openingRouteKeys.includes(curr.key) &&\n          animationEnabled !== false\n            ? getDistanceFromOptions(props.mode, state.layout, descriptor)\n            : 0\n        );\n\n      return acc;\n    }, {});\n\n    return {\n      routes: props.routes,\n      scenes: props.routes.map((route, index, self) => {\n        const previousRoute = self[index - 1];\n        const nextRoute = self[index + 1];\n\n        const oldScene = state.scenes[index];\n\n        const currentGesture = gestures[route.key];\n        const previousGesture = previousRoute\n          ? gestures[previousRoute.key]\n          : undefined;\n        const nextGesture = nextRoute ? gestures[nextRoute.key] : undefined;\n\n        const descriptor =\n          props.descriptors[route.key] ||\n          state.descriptors[route.key] ||\n          (oldScene ? oldScene.descriptor : FALLBACK_DESCRIPTOR);\n\n        const nextDescriptor =\n          props.descriptors[nextRoute?.key] ||\n          state.descriptors[nextRoute?.key];\n\n        const previousDescriptor =\n          props.descriptors[previousRoute?.key] ||\n          state.descriptors[previousRoute?.key];\n\n        const scene = {\n          route,\n          descriptor,\n          progress: {\n            current: getProgressFromGesture(\n              props.mode,\n              currentGesture,\n              state.layout,\n              descriptor\n            ),\n            next: nextGesture\n              ? getProgressFromGesture(\n                  props.mode,\n                  nextGesture,\n                  state.layout,\n                  nextDescriptor\n                )\n              : undefined,\n            previous: previousGesture\n              ? getProgressFromGesture(\n                  props.mode,\n                  previousGesture,\n                  state.layout,\n                  previousDescriptor\n                )\n              : undefined,\n          },\n          __memo: [\n            route,\n            state.layout,\n            descriptor,\n            nextDescriptor,\n            previousDescriptor,\n            currentGesture,\n            nextGesture,\n            previousGesture,\n          ],\n        };\n\n        if (\n          oldScene &&\n          scene.__memo.every((it, i) => {\n            // @ts-expect-error: we haven't added __memo to the annotation to prevent usage elsewhere\n            return oldScene.__memo[i] === it;\n          })\n        ) {\n          return oldScene;\n        }\n\n        return scene;\n      }),\n      gestures,\n      descriptors: props.descriptors,\n      headerHeights: getHeaderHeights(\n        props.routes,\n        props.insets,\n        props.isParentHeaderShown,\n        state.descriptors,\n        state.layout,\n        state.headerHeights\n      ),\n    };\n  }\n\n  constructor(props: Props) {\n    super(props);\n\n    const { height = 0, width = 0 } = Dimensions.get('window');\n\n    this.state = {\n      routes: [],\n      scenes: [],\n      gestures: {},\n      layout: { height, width },\n      descriptors: this.props.descriptors,\n      // Used when card's header is null and mode is float to make transition\n      // between screens with headers and those without headers smooth.\n      // This is not a great heuristic here. We don't know synchronously\n      // on mount what the header height is so we have just used the most\n      // common cases here.\n      headerHeights: {},\n    };\n  }\n\n  private handleLayout = (e: LayoutChangeEvent) => {\n    const { height, width } = e.nativeEvent.layout;\n\n    const layout = { width, height };\n\n    this.setState((state, props) => {\n      if (height === state.layout.height && width === state.layout.width) {\n        return null;\n      }\n\n      return {\n        layout,\n        headerHeights: getHeaderHeights(\n          props.routes,\n          props.insets,\n          props.isParentHeaderShown,\n          state.descriptors,\n          layout,\n          state.headerHeights\n        ),\n      };\n    });\n  };\n\n  private handleHeaderLayout = ({\n    route,\n    height,\n  }: {\n    route: Route<string>;\n    height: number;\n  }) => {\n    this.setState(({ headerHeights }) => {\n      const previousHeight = headerHeights[route.key];\n\n      if (previousHeight === height) {\n        return null;\n      }\n\n      return {\n        headerHeights: {\n          ...headerHeights,\n          [route.key]: height,\n        },\n      };\n    });\n  };\n\n  private getFocusedRoute = () => {\n    const { state } = this.props;\n\n    return state.routes[state.index];\n  };\n\n  private getPreviousScene = ({ route }: { route: Route<string> }) => {\n    const { getPreviousRoute } = this.props;\n    const { scenes } = this.state;\n\n    const previousRoute = getPreviousRoute({ route });\n\n    if (previousRoute) {\n      const previousScene = scenes.find(\n        (scene) => scene.route.key === previousRoute.key\n      );\n\n      return previousScene;\n    }\n\n    return undefined;\n  };\n\n  render() {\n    const {\n      mode,\n      insets,\n      descriptors,\n      state,\n      routes,\n      closingRouteKeys,\n      onOpenRoute,\n      onCloseRoute,\n      getGesturesEnabled,\n      renderHeader,\n      renderScene,\n      headerMode,\n      isParentHeaderShown,\n      onTransitionStart,\n      onTransitionEnd,\n      onPageChangeStart,\n      onPageChangeConfirm,\n      onPageChangeCancel,\n      onGestureStart,\n      onGestureEnd,\n      onGestureCancel,\n      // Enable on new versions of `react-native-screens`\n      // On older versions of `react-native-screens`, there's an issue with screens not being responsive to user interaction.\n      detachInactiveScreens = Platform.OS === 'web' || shouldUseActivityState,\n    } = this.props;\n\n    const { scenes, layout, gestures, headerHeights } = this.state;\n\n    const focusedRoute = state.routes[state.index];\n    const focusedDescriptor = descriptors[focusedRoute.key];\n    const focusedOptions = focusedDescriptor ? focusedDescriptor.options : {};\n    const focusedHeaderHeight = headerHeights[focusedRoute.key];\n\n    let defaultTransitionPreset =\n      mode === 'modal' ? ModalTransition : DefaultTransition;\n\n    if (headerMode === 'screen') {\n      defaultTransitionPreset = {\n        ...defaultTransitionPreset,\n        headerStyleInterpolator: forNoAnimationHeader,\n      };\n    }\n\n    const {\n      top = insets.top,\n      right = insets.right,\n      bottom = insets.bottom,\n      left = insets.left,\n    } = focusedOptions.safeAreaInsets || {};\n\n    let activeScreensLimit = 1;\n\n    for (let i = scenes.length - 1; i >= 0; i--) {\n      const {\n        // By default, we don't want to detach the previous screen of the active one for modals\n        detachPreviousScreen = mode === 'modal'\n          ? i !== scenes.length - 1\n          : true,\n      } = scenes[i].descriptor.options;\n\n      if (detachPreviousScreen === false) {\n        activeScreensLimit++;\n      } else {\n        break;\n      }\n    }\n\n    const isFloatHeaderAbsolute =\n      headerMode === 'float'\n        ? this.state.scenes.slice(-2).some((scene) => {\n            const { descriptor } = scene;\n            const options = descriptor ? descriptor.options : {};\n            const { headerTransparent, headerShown = true } = options;\n\n            if (headerTransparent || headerShown === false) {\n              return true;\n            }\n\n            return false;\n          })\n        : false;\n\n    const floatingHeader =\n      headerMode === 'float' ? (\n        <React.Fragment key=\"header\">\n          {renderHeader({\n            mode: 'float',\n            layout,\n            insets: { top, right, bottom, left },\n            scenes,\n            getPreviousScene: this.getPreviousScene,\n            getFocusedRoute: this.getFocusedRoute,\n            onContentHeightChange: this.handleHeaderLayout,\n            gestureDirection:\n              focusedOptions.gestureDirection !== undefined\n                ? focusedOptions.gestureDirection\n                : defaultTransitionPreset.gestureDirection,\n            styleInterpolator:\n              focusedOptions.headerStyleInterpolator !== undefined\n                ? focusedOptions.headerStyleInterpolator\n                : defaultTransitionPreset.headerStyleInterpolator,\n            style: [\n              styles.floating,\n              isFloatHeaderAbsolute && [\n                // Without this, the header buttons won't be touchable on Android when headerTransparent: true\n                { height: focusedHeaderHeight },\n                styles.absolute,\n              ],\n            ],\n          })}\n        </React.Fragment>\n      ) : null;\n\n    return (\n      <React.Fragment>\n        {isFloatHeaderAbsolute ? null : floatingHeader}\n        <MaybeScreenContainer\n          enabled={detachInactiveScreens}\n          style={styles.container}\n          onLayout={this.handleLayout}\n        >\n          {routes.map((route, index, self) => {\n            const focused = focusedRoute.key === route.key;\n            const gesture = gestures[route.key];\n            const scene = scenes[index];\n\n            // For the screens that shouldn't be active, the value is 0\n            // For those that should be active, but are not the top screen, the value is 1\n            // For those on top of the stack and with interaction enabled, the value is 2\n            // For the old implementation, it stays the same it was\n            let isScreenActive: Animated.AnimatedInterpolation | 2 | 1 | 0 = 1;\n\n            if (shouldUseActivityState || Platform.OS === 'web') {\n              if (index < self.length - activeScreensLimit - 1) {\n                // screen should be inactive because it is too deep in the stack\n                isScreenActive = STATE_INACTIVE;\n              } else {\n                const sceneForActivity = scenes[self.length - 1];\n                const outputValue =\n                  index === self.length - 1\n                    ? STATE_ON_TOP // the screen is on top after the transition\n                    : index >= self.length - activeScreensLimit\n                    ? STATE_TRANSITIONING_OR_BELOW_TOP // the screen should stay active after the transition, it is not on top but is in activeLimit\n                    : STATE_INACTIVE; // the screen should be active only during the transition, it is at the edge of activeLimit\n                isScreenActive = sceneForActivity\n                  ? sceneForActivity.progress.current.interpolate({\n                      inputRange: [0, 1 - EPSILON, 1],\n                      outputRange: [1, 1, outputValue],\n                      extrapolate: 'clamp',\n                    })\n                  : STATE_TRANSITIONING_OR_BELOW_TOP;\n              }\n            } else {\n              isScreenActive = scene.progress.next\n                ? scene.progress.next.interpolate({\n                    inputRange: [0, 1 - EPSILON, 1],\n                    outputRange: [1, 1, 0],\n                    extrapolate: 'clamp',\n                  })\n                : 1;\n            }\n\n            const {\n              safeAreaInsets,\n              headerShown = true,\n              headerTransparent,\n              cardShadowEnabled,\n              cardOverlayEnabled,\n              cardOverlay,\n              cardStyle,\n              animationEnabled,\n              gestureResponseDistance,\n              gestureVelocityImpact,\n              gestureDirection = defaultTransitionPreset.gestureDirection,\n              transitionSpec = defaultTransitionPreset.transitionSpec,\n              cardStyleInterpolator = animationEnabled === false\n                ? forNoAnimationCard\n                : defaultTransitionPreset.cardStyleInterpolator,\n              headerStyleInterpolator = defaultTransitionPreset.headerStyleInterpolator,\n            } = scene.descriptor\n              ? scene.descriptor.options\n              : ({} as StackNavigationOptions);\n\n            let transitionConfig = {\n              gestureDirection,\n              transitionSpec,\n              cardStyleInterpolator,\n              headerStyleInterpolator,\n            };\n\n            // When a screen is not the last, it should use next screen's transition config\n            // Many transitions also animate the previous screen, so using 2 different transitions doesn't look right\n            // For example combining a slide and a modal transition would look wrong otherwise\n            // With this approach, combining different transition styles in the same navigator mostly looks right\n            // This will still be broken when 2 transitions have different idle state (e.g. modal presentation),\n            // but majority of the transitions look alright\n            if (index !== self.length - 1) {\n              const nextScene = scenes[index + 1];\n\n              if (nextScene) {\n                const {\n                  animationEnabled,\n                  gestureDirection = defaultTransitionPreset.gestureDirection,\n                  transitionSpec = defaultTransitionPreset.transitionSpec,\n                  cardStyleInterpolator = animationEnabled === false\n                    ? forNoAnimationCard\n                    : defaultTransitionPreset.cardStyleInterpolator,\n                  headerStyleInterpolator = defaultTransitionPreset.headerStyleInterpolator,\n                } = nextScene.descriptor\n                  ? nextScene.descriptor.options\n                  : ({} as StackNavigationOptions);\n\n                transitionConfig = {\n                  gestureDirection,\n                  transitionSpec,\n                  cardStyleInterpolator,\n                  headerStyleInterpolator,\n                };\n              }\n            }\n\n            const {\n              top: safeAreaInsetTop = insets.top,\n              right: safeAreaInsetRight = insets.right,\n              bottom: safeAreaInsetBottom = insets.bottom,\n              left: safeAreaInsetLeft = insets.left,\n            } = safeAreaInsets || {};\n\n            const headerHeight =\n              headerMode !== 'none' && headerShown !== false\n                ? headerHeights[route.key]\n                : 0;\n\n            return (\n              <MaybeScreen\n                key={route.key}\n                style={StyleSheet.absoluteFill}\n                enabled={detachInactiveScreens}\n                active={isScreenActive}\n                pointerEvents=\"box-none\"\n              >\n                <CardContainer\n                  index={index}\n                  active={index === self.length - 1}\n                  focused={focused}\n                  closing={closingRouteKeys.includes(route.key)}\n                  layout={layout}\n                  gesture={gesture}\n                  scene={scene}\n                  safeAreaInsetTop={safeAreaInsetTop}\n                  safeAreaInsetRight={safeAreaInsetRight}\n                  safeAreaInsetBottom={safeAreaInsetBottom}\n                  safeAreaInsetLeft={safeAreaInsetLeft}\n                  cardOverlay={cardOverlay}\n                  cardOverlayEnabled={cardOverlayEnabled}\n                  cardShadowEnabled={cardShadowEnabled}\n                  cardStyle={cardStyle}\n                  onPageChangeStart={onPageChangeStart}\n                  onPageChangeConfirm={onPageChangeConfirm}\n                  onPageChangeCancel={onPageChangeCancel}\n                  onGestureStart={onGestureStart}\n                  onGestureCancel={onGestureCancel}\n                  onGestureEnd={onGestureEnd}\n                  gestureResponseDistance={gestureResponseDistance}\n                  headerHeight={headerHeight}\n                  isParentHeaderShown={isParentHeaderShown}\n                  onHeaderHeightChange={this.handleHeaderLayout}\n                  getPreviousScene={this.getPreviousScene}\n                  getFocusedRoute={this.getFocusedRoute}\n                  mode={mode}\n                  headerMode={headerMode}\n                  headerShown={headerShown}\n                  hasAbsoluteHeader={\n                    isFloatHeaderAbsolute && !headerTransparent\n                  }\n                  renderHeader={renderHeader}\n                  renderScene={renderScene}\n                  onOpenRoute={onOpenRoute}\n                  onCloseRoute={onCloseRoute}\n                  onTransitionStart={onTransitionStart}\n                  onTransitionEnd={onTransitionEnd}\n                  gestureEnabled={index !== 0 && getGesturesEnabled({ route })}\n                  gestureVelocityImpact={gestureVelocityImpact}\n                  {...transitionConfig}\n                />\n              </MaybeScreen>\n            );\n          })}\n        </MaybeScreenContainer>\n        {isFloatHeaderAbsolute ? floatingHeader : null}\n      </React.Fragment>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  absolute: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n  },\n  floating: {\n    zIndex: 1,\n  },\n});\n","import * as React from 'react';\nimport { TextInput, Keyboard, HostComponent } from 'react-native';\n\ntype Props = {\n  enabled: boolean;\n  children: (props: {\n    onPageChangeStart: () => void;\n    onPageChangeConfirm: (force: boolean) => void;\n    onPageChangeCancel: () => void;\n  }) => React.ReactNode;\n};\n\ntype InputRef = React.ElementRef<HostComponent<unknown>> | undefined;\n\nexport default class KeyboardManager extends React.Component<Props> {\n  componentWillUnmount() {\n    this.clearKeyboardTimeout();\n  }\n\n  // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n  private previouslyFocusedTextInput: InputRef = undefined;\n  private startTimestamp: number = 0;\n  private keyboardTimeout: any;\n\n  private clearKeyboardTimeout = () => {\n    if (this.keyboardTimeout !== undefined) {\n      clearTimeout(this.keyboardTimeout);\n      this.keyboardTimeout = undefined;\n    }\n  };\n\n  private handlePageChangeStart = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // @ts-expect-error: blurTextInput accepts both number and ref, but types say only ref\n    const input: InputRef = TextInput.State.currentlyFocusedInput\n      ? TextInput.State.currentlyFocusedInput()\n      : TextInput.State.currentlyFocusedField();\n\n    // When a page change begins, blur the currently focused input\n    TextInput.State.blurTextInput(input);\n\n    // Store the id of this input so we can refocus it if change was cancelled\n    this.previouslyFocusedTextInput = input;\n\n    // Store timestamp for touch start\n    this.startTimestamp = Date.now();\n  };\n\n  private handlePageChangeConfirm = (force: boolean) => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    if (force) {\n      // Always dismiss input, even if we don't have a ref to it\n      // We might not have the ref if onPageChangeStart was never called\n      // This can happen if page change was not from a gesture\n      Keyboard.dismiss();\n    } else {\n      const input = this.previouslyFocusedTextInput;\n\n      if (input) {\n        // Dismiss the keyboard only if an input was a focused before\n        // This makes sure we don't dismiss input on going back and focusing an input\n        TextInput.State.blurTextInput(input);\n      }\n    }\n\n    // Cleanup the ID on successful page change\n    this.previouslyFocusedTextInput = undefined;\n  };\n\n  private handlePageChangeCancel = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // The page didn't change, we should restore the focus of text input\n    const input = this.previouslyFocusedTextInput;\n\n    if (input) {\n      // If the interaction was super short we should make sure keyboard won't hide again.\n\n      // Too fast input refocus will result only in keyboard flashing on screen and hiding right away.\n      // During first ~100ms keyboard will be dismissed no matter what,\n      // so we have to make sure it won't interrupt input refocus logic.\n      // That's why when the interaction is shorter than 100ms we add delay so it won't hide once again.\n      // Subtracting timestamps makes us sure the delay is executed only when needed.\n      if (Date.now() - this.startTimestamp < 100) {\n        this.keyboardTimeout = setTimeout(() => {\n          TextInput.State.focusTextInput(input);\n          this.previouslyFocusedTextInput = undefined;\n        }, 100);\n      } else {\n        TextInput.State.focusTextInput(input);\n        this.previouslyFocusedTextInput = undefined;\n      }\n    }\n  };\n\n  render() {\n    return this.props.children({\n      onPageChangeStart: this.handlePageChangeStart,\n      onPageChangeConfirm: this.handlePageChangeConfirm,\n      onPageChangeCancel: this.handlePageChangeCancel,\n    });\n  }\n}\n","import * as React from 'react';\nimport {\n  Animated,\n  StyleSheet,\n  Platform,\n  TextProps,\n  StyleProp,\n  TextStyle,\n} from 'react-native';\nimport { useTheme } from '@react-navigation/native';\n\ntype Props = Omit<TextProps, 'style'> & {\n  tintColor?: string;\n  children?: string;\n  style?: Animated.WithAnimatedValue<StyleProp<TextStyle>>;\n};\n\nexport default function HeaderTitle({ tintColor, style, ...rest }: Props) {\n  const { colors } = useTheme();\n\n  return (\n    <Animated.Text\n      accessibilityRole=\"header\"\n      aria-level=\"1\"\n      numberOfLines={1}\n      {...rest}\n      style={[\n        styles.title,\n        { color: tintColor === undefined ? colors.text : tintColor },\n        style,\n      ]}\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  title: Platform.select({\n    ios: {\n      fontSize: 17,\n      fontWeight: '600',\n    },\n    android: {\n      fontSize: 20,\n      fontFamily: 'sans-serif-medium',\n      fontWeight: 'normal',\n    },\n    default: {\n      fontSize: 18,\n      fontWeight: '500',\n    },\n  }),\n});\n","import * as React from 'react';\nimport { StackActions } from '@react-navigation/native';\n\nimport HeaderSegment from './HeaderSegment';\nimport HeaderTitle from './HeaderTitle';\nimport debounce from '../../utils/debounce';\nimport type { StackHeaderProps, StackHeaderTitleProps } from '../../types';\n\nexport default React.memo(function Header(props: StackHeaderProps) {\n  const {\n    scene,\n    previous,\n    layout,\n    insets,\n    navigation,\n    styleInterpolator,\n  } = props;\n  const { options } = scene.descriptor;\n  const title =\n    typeof options.headerTitle !== 'function' &&\n    options.headerTitle !== undefined\n      ? options.headerTitle\n      : options.title !== undefined\n      ? options.title\n      : scene.route.name;\n\n  let leftLabel;\n\n  // The label for the left back button shows the title of the previous screen\n  // If a custom label is specified, we use it, otherwise use previous screen's title\n  if (options.headerBackTitle !== undefined) {\n    leftLabel = options.headerBackTitle;\n  } else if (previous) {\n    const o = previous.descriptor.options;\n\n    leftLabel =\n      typeof o.headerTitle !== 'function' && o.headerTitle !== undefined\n        ? o.headerTitle\n        : o.title !== undefined\n        ? o.title\n        : previous.route.name;\n  }\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const goBack = React.useCallback(\n    debounce(() => {\n      if (navigation.isFocused() && navigation.canGoBack()) {\n        navigation.dispatch({\n          ...StackActions.pop(),\n          source: scene.route.key,\n        });\n      }\n    }, 50),\n    [navigation, scene.route.key]\n  );\n\n  return (\n    <HeaderSegment\n      {...options}\n      insets={insets}\n      layout={layout}\n      scene={scene}\n      title={title}\n      leftLabel={leftLabel}\n      headerTitle={\n        typeof options.headerTitle !== 'function'\n          ? (props: StackHeaderTitleProps) => <HeaderTitle {...props} />\n          : options.headerTitle\n      }\n      onGoBack={previous ? goBack : undefined}\n      styleInterpolator={styleInterpolator}\n    />\n  );\n});\n","export default function debounce<T extends (...args: any[]) => void>(\n  func: T,\n  duration: number\n): T {\n  let timeout: NodeJS.Timeout | number | undefined;\n\n  return function (this: any, ...args) {\n    if (!timeout) {\n      // eslint-disable-next-line babel/no-invalid-this\n      func.apply(this, args);\n\n      timeout = setTimeout(() => {\n        timeout = undefined;\n      }, duration);\n    }\n  } as T;\n}\n","import * as React from 'react';\nimport { Animated, View, StyleSheet, StyleProp, ViewStyle } from 'react-native';\nimport {\n  NavigationContext,\n  NavigationRouteContext,\n  Route,\n  ParamListBase,\n} from '@react-navigation/native';\nimport type { EdgeInsets } from 'react-native-safe-area-context';\n\nimport Header from './Header';\nimport {\n  forSlideLeft,\n  forSlideUp,\n  forNoAnimation,\n  forSlideRight,\n} from '../../TransitionConfigs/HeaderStyleInterpolators';\nimport PreviousSceneContext from '../../utils/PreviousSceneContext';\nimport type {\n  Layout,\n  Scene,\n  StackHeaderStyleInterpolator,\n  StackNavigationProp,\n  GestureDirection,\n} from '../../types';\n\nexport type Props = {\n  mode: 'float' | 'screen';\n  layout: Layout;\n  insets: EdgeInsets;\n  scenes: (Scene<Route<string>> | undefined)[];\n  getPreviousScene: (props: {\n    route: Route<string>;\n  }) => Scene<Route<string>> | undefined;\n  getFocusedRoute: () => Route<string>;\n  onContentHeightChange?: (props: {\n    route: Route<string>;\n    height: number;\n  }) => void;\n  styleInterpolator: StackHeaderStyleInterpolator;\n  gestureDirection: GestureDirection;\n  style?: StyleProp<ViewStyle>;\n};\n\nexport default function HeaderContainer({\n  mode,\n  scenes,\n  layout,\n  insets,\n  getPreviousScene,\n  getFocusedRoute,\n  onContentHeightChange,\n  gestureDirection,\n  styleInterpolator,\n  style,\n}: Props) {\n  const focusedRoute = getFocusedRoute();\n  const parentPreviousScene = React.useContext(PreviousSceneContext);\n\n  return (\n    <Animated.View pointerEvents=\"box-none\" style={style}>\n      {scenes.slice(-3).map((scene, i, self) => {\n        if ((mode === 'screen' && i !== self.length - 1) || !scene) {\n          return null;\n        }\n\n        const { header, headerShown = true, headerTransparent } =\n          scene.descriptor.options || {};\n\n        if (!headerShown) {\n          return null;\n        }\n\n        const isFocused = focusedRoute.key === scene.route.key;\n        const previous =\n          getPreviousScene({ route: scene.route }) ?? parentPreviousScene;\n\n        // If the screen is next to a headerless screen, we need to make the header appear static\n        // This makes the header look like it's moving with the screen\n        const previousScene = self[i - 1];\n        const nextScene = self[i + 1];\n\n        const { headerShown: previousHeaderShown = true } =\n          previousScene?.descriptor.options || {};\n\n        const { headerShown: nextHeaderShown = true } =\n          nextScene?.descriptor.options || {};\n\n        const isHeaderStatic =\n          (previousHeaderShown === false &&\n            // We still need to animate when coming back from next scene\n            // A hacky way to check this is if the next scene exists\n            !nextScene) ||\n          nextHeaderShown === false;\n\n        const props = {\n          mode,\n          layout,\n          insets,\n          scene,\n          previous,\n          navigation: scene.descriptor.navigation as StackNavigationProp<\n            ParamListBase\n          >,\n          styleInterpolator:\n            mode === 'float'\n              ? isHeaderStatic\n                ? gestureDirection === 'vertical' ||\n                  gestureDirection === 'vertical-inverted'\n                  ? forSlideUp\n                  : gestureDirection === 'horizontal-inverted'\n                  ? forSlideRight\n                  : forSlideLeft\n                : styleInterpolator\n              : forNoAnimation,\n        };\n\n        return (\n          <NavigationContext.Provider\n            key={scene.route.key}\n            value={scene.descriptor.navigation}\n          >\n            <NavigationRouteContext.Provider value={scene.route}>\n              <View\n                onLayout={\n                  onContentHeightChange\n                    ? (e) => {\n                        const { height } = e.nativeEvent.layout;\n\n                        onContentHeightChange({\n                          route: scene.route,\n                          height,\n                        });\n                      }\n                    : undefined\n                }\n                pointerEvents={isFocused ? 'box-none' : 'none'}\n                accessibilityElementsHidden={!isFocused}\n                importantForAccessibility={\n                  isFocused ? 'auto' : 'no-hide-descendants'\n                }\n                style={\n                  // Avoid positioning the focused header absolutely\n                  // Otherwise accessibility tools don't seem to be able to find it\n                  (mode === 'float' && !isFocused) || headerTransparent\n                    ? styles.header\n                    : null\n                }\n              >\n                {header !== undefined ? header(props) : <Header {...props} />}\n              </View>\n            </NavigationRouteContext.Provider>\n          </NavigationContext.Provider>\n        );\n      })}\n    </Animated.View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n  },\n});\n","import * as React from 'react';\nimport {\n  SafeAreaProvider,\n  SafeAreaConsumer,\n  initialWindowSafeAreaInsets,\n} from 'react-native-safe-area-context';\nimport {\n  getStatusBarHeight,\n  getBottomSpace,\n} from 'react-native-iphone-x-helper';\n\n// The provider component for safe area initializes asynchornously\n// Until the insets are available, there'll be blank screen\n// To avoid the blank screen, we specify some initial values\nconst initialSafeAreaInsets = {\n  // Approximate values which are good enough for most cases\n  top: getStatusBarHeight(true),\n  bottom: getBottomSpace(),\n  right: 0,\n  left: 0,\n  // If we are on a newer version of the library, we can get the correct window insets\n  // The component might not be filling the window, but this is good enough for most cases\n  ...initialWindowSafeAreaInsets,\n};\n\ntype Props = {\n  children: React.ReactNode;\n};\n\nexport default function SafeAreaProviderCompat({ children }: Props) {\n  return (\n    <SafeAreaConsumer>\n      {(insets) => {\n        if (insets) {\n          // If we already have insets, don't wrap the stack in another safe area provider\n          // This avoids an issue with updates at the cost of potentially incorrect values\n          // https://github.com/react-navigation/react-navigation/issues/174\n          return children;\n        }\n\n        return (\n          <SafeAreaProvider initialSafeAreaInsets={initialSafeAreaInsets}>\n            {children}\n          </SafeAreaProvider>\n        );\n      }}\n    </SafeAreaConsumer>\n  );\n}\n","import * as React from 'react';\nimport { View, Platform, StyleSheet } from 'react-native';\nimport { SafeAreaConsumer, EdgeInsets } from 'react-native-safe-area-context';\nimport {\n  NavigationHelpersContext,\n  StackActions,\n  StackNavigationState,\n  Route,\n  ParamListBase,\n} from '@react-navigation/native';\n\nimport { GestureHandlerRootView } from '../GestureHandler';\nimport CardStack from './CardStack';\nimport KeyboardManager from '../KeyboardManager';\nimport HeaderContainer, {\n  Props as HeaderContainerProps,\n} from '../Header/HeaderContainer';\nimport SafeAreaProviderCompat from '../SafeAreaProviderCompat';\nimport type {\n  StackNavigationHelpers,\n  StackNavigationConfig,\n  StackDescriptorMap,\n} from '../../types';\nimport HeaderShownContext from '../../utils/HeaderShownContext';\n\ntype Props = StackNavigationConfig & {\n  state: StackNavigationState<ParamListBase>;\n  navigation: StackNavigationHelpers;\n  descriptors: StackDescriptorMap;\n};\n\ntype State = {\n  // Local copy of the routes which are actually rendered\n  routes: Route<string>[];\n  // Previous routes, to compare whether routes have changed or not\n  previousRoutes: Route<string>[];\n  // Previous descriptors, to compare whether descriptors have changed or not\n  previousDescriptors: StackDescriptorMap;\n  // List of routes being opened, we need to animate pushing of these new routes\n  openingRouteKeys: string[];\n  // List of routes being closed, we need to animate popping of these routes\n  closingRouteKeys: string[];\n  // List of routes being replaced, we need to keep a copy until the new route animates in\n  replacingRouteKeys: string[];\n  // Since the local routes can vary from the routes from props, we need to keep the descriptors for old routes\n  // Otherwise we won't be able to access the options for routes that were removed\n  descriptors: StackDescriptorMap;\n};\n\nconst GestureHandlerWrapper = GestureHandlerRootView ?? View;\n\n/**\n * Compare two arrays with primitive values as the content.\n * We need to make sure that both values and order match.\n */\nconst isArrayEqual = (a: any[], b: any[]) =>\n  a.length === b.length && a.every((it, index) => it === b[index]);\n\nexport default class StackView extends React.Component<Props, State> {\n  static getDerivedStateFromProps(\n    props: Readonly<Props>,\n    state: Readonly<State>\n  ) {\n    // If there was no change in routes, we don't need to compute anything\n    if (\n      (props.state.routes === state.previousRoutes ||\n        isArrayEqual(\n          props.state.routes.map((r) => r.key),\n          state.previousRoutes.map((r) => r.key)\n        )) &&\n      state.routes.length\n    ) {\n      let routes = state.routes;\n      let previousRoutes = state.previousRoutes;\n      let descriptors = props.descriptors;\n      let previousDescriptors = state.previousDescriptors;\n\n      if (props.descriptors !== state.previousDescriptors) {\n        descriptors = state.routes.reduce<StackDescriptorMap>((acc, route) => {\n          acc[route.key] =\n            props.descriptors[route.key] || state.descriptors[route.key];\n\n          return acc;\n        }, {});\n\n        previousDescriptors = props.descriptors;\n      }\n\n      if (props.state.routes !== state.previousRoutes) {\n        // if any route objects have changed, we should update them\n        const map = props.state.routes.reduce<Record<string, Route<string>>>(\n          (acc, route) => {\n            acc[route.key] = route;\n            return acc;\n          },\n          {}\n        );\n\n        routes = state.routes.map((route) => map[route.key] || route);\n        previousRoutes = props.state.routes;\n      }\n\n      return {\n        routes,\n        previousRoutes,\n        descriptors,\n        previousDescriptors,\n      };\n    }\n\n    // Here we determine which routes were added or removed to animate them\n    // We keep a copy of the route being removed in local state to be able to animate it\n\n    let routes =\n      props.state.index < props.state.routes.length - 1\n        ? // Remove any extra routes from the state\n          // The last visible route should be the focused route, i.e. at current index\n          props.state.routes.slice(0, props.state.index + 1)\n        : props.state.routes;\n\n    // Now we need to determine which routes were added and removed\n    let {\n      openingRouteKeys,\n      closingRouteKeys,\n      replacingRouteKeys,\n      previousRoutes,\n    } = state;\n\n    const previousFocusedRoute = previousRoutes[previousRoutes.length - 1] as\n      | Route<string>\n      | undefined;\n    const nextFocusedRoute = routes[routes.length - 1];\n\n    const isAnimationEnabled = (key: string) => {\n      const descriptor = props.descriptors[key] || state.descriptors[key];\n\n      return descriptor ? descriptor.options.animationEnabled !== false : true;\n    };\n\n    const getAnimationTypeForReplace = (key: string) => {\n      const descriptor = props.descriptors[key] || state.descriptors[key];\n\n      return descriptor.options.animationTypeForReplace ?? 'push';\n    };\n\n    if (\n      previousFocusedRoute &&\n      previousFocusedRoute.key !== nextFocusedRoute.key\n    ) {\n      // We only need to animate routes if the focused route changed\n      // Animating previous routes won't be visible coz the focused route is on top of everything\n\n      if (!previousRoutes.some((r) => r.key === nextFocusedRoute.key)) {\n        // A new route has come to the focus, we treat this as a push\n        // A replace can also trigger this, the animation should look like push\n\n        if (\n          isAnimationEnabled(nextFocusedRoute.key) &&\n          !openingRouteKeys.includes(nextFocusedRoute.key)\n        ) {\n          // In this case, we need to animate pushing the focused route\n          // We don't care about animating any other added routes because they won't be visible\n          openingRouteKeys = [...openingRouteKeys, nextFocusedRoute.key];\n\n          closingRouteKeys = closingRouteKeys.filter(\n            (key) => key !== nextFocusedRoute.key\n          );\n          replacingRouteKeys = replacingRouteKeys.filter(\n            (key) => key !== nextFocusedRoute.key\n          );\n\n          if (!routes.some((r) => r.key === previousFocusedRoute.key)) {\n            // The previous focused route isn't present in state, we treat this as a replace\n\n            openingRouteKeys = openingRouteKeys.filter(\n              (key) => key !== previousFocusedRoute.key\n            );\n\n            if (getAnimationTypeForReplace(nextFocusedRoute.key) === 'pop') {\n              closingRouteKeys = [\n                ...closingRouteKeys,\n                previousFocusedRoute.key,\n              ];\n\n              // By default, new routes have a push animation, so we add it to `openingRouteKeys` before\n              // But since user configured it to animate the old screen like a pop, we need to add this without animation\n              // So remove it from `openingRouteKeys` which will remove the animation\n              openingRouteKeys = openingRouteKeys.filter(\n                (key) => key !== nextFocusedRoute.key\n              );\n\n              // Keep the route being removed at the end to animate it out\n              routes = [...routes, previousFocusedRoute];\n            } else {\n              replacingRouteKeys = [\n                ...replacingRouteKeys,\n                previousFocusedRoute.key,\n              ];\n\n              closingRouteKeys = closingRouteKeys.filter(\n                (key) => key !== previousFocusedRoute.key\n              );\n\n              // Keep the old route in the state because it's visible under the new route, and removing it will feel abrupt\n              // We need to insert it just before the focused one (the route being pushed)\n              // After the push animation is completed, routes being replaced will be removed completely\n              routes = routes.slice();\n              routes.splice(routes.length - 1, 0, previousFocusedRoute);\n            }\n          }\n        }\n      } else if (!routes.some((r) => r.key === previousFocusedRoute.key)) {\n        // The previously focused route was removed, we treat this as a pop\n\n        if (\n          isAnimationEnabled(previousFocusedRoute.key) &&\n          !closingRouteKeys.includes(previousFocusedRoute.key)\n        ) {\n          closingRouteKeys = [...closingRouteKeys, previousFocusedRoute.key];\n\n          // Sometimes a route can be closed before the opening animation finishes\n          // So we also need to remove it from the opening list\n          openingRouteKeys = openingRouteKeys.filter(\n            (key) => key !== previousFocusedRoute.key\n          );\n          replacingRouteKeys = replacingRouteKeys.filter(\n            (key) => key !== previousFocusedRoute.key\n          );\n\n          // Keep a copy of route being removed in the state to be able to animate it\n          routes = [...routes, previousFocusedRoute];\n        }\n      } else {\n        // Looks like some routes were re-arranged and no focused routes were added/removed\n        // i.e. the currently focused route already existed and the previously focused route still exists\n        // We don't know how to animate this\n      }\n    } else if (replacingRouteKeys.length || closingRouteKeys.length) {\n      // Keep the routes we are closing or replacing if animation is enabled for them\n      routes = routes.slice();\n      routes.splice(\n        routes.length - 1,\n        0,\n        ...state.routes.filter(({ key }) =>\n          isAnimationEnabled(key)\n            ? replacingRouteKeys.includes(key) || closingRouteKeys.includes(key)\n            : false\n        )\n      );\n    }\n\n    if (!routes.length) {\n      throw new Error(\n        'There should always be at least one route in the navigation state.'\n      );\n    }\n\n    const descriptors = routes.reduce<StackDescriptorMap>((acc, route) => {\n      acc[route.key] =\n        props.descriptors[route.key] || state.descriptors[route.key];\n\n      return acc;\n    }, {});\n\n    return {\n      routes,\n      previousRoutes: props.state.routes,\n      previousDescriptors: props.descriptors,\n      openingRouteKeys,\n      closingRouteKeys,\n      replacingRouteKeys,\n      descriptors,\n    };\n  }\n\n  state: State = {\n    routes: [],\n    previousRoutes: [],\n    previousDescriptors: {},\n    openingRouteKeys: [],\n    closingRouteKeys: [],\n    replacingRouteKeys: [],\n    descriptors: {},\n  };\n\n  private getGesturesEnabled = ({ route }: { route: Route<string> }) => {\n    const descriptor = this.state.descriptors[route.key];\n\n    if (descriptor) {\n      const { gestureEnabled, animationEnabled } = descriptor.options;\n\n      if (animationEnabled === false) {\n        // When animation is disabled, also disable gestures\n        // The gesture to dismiss a route will look weird when not animated\n        return false;\n      }\n\n      return gestureEnabled !== false;\n    }\n\n    return false;\n  };\n\n  private getPreviousRoute = ({ route }: { route: Route<string> }) => {\n    const { closingRouteKeys, replacingRouteKeys } = this.state;\n    const routes = this.state.routes.filter(\n      (r) =>\n        r.key === route.key ||\n        (!closingRouteKeys.includes(r.key) &&\n          !replacingRouteKeys.includes(r.key))\n    );\n\n    const index = routes.findIndex((r) => r.key === route.key);\n\n    return routes[index - 1];\n  };\n\n  private renderScene = ({ route }: { route: Route<string> }) => {\n    const descriptor =\n      this.state.descriptors[route.key] || this.props.descriptors[route.key];\n\n    if (!descriptor) {\n      return null;\n    }\n\n    return descriptor.render();\n  };\n\n  private renderHeader = (props: HeaderContainerProps) => {\n    return <HeaderContainer {...props} />;\n  };\n\n  private handleOpenRoute = ({ route }: { route: Route<string> }) => {\n    const { state, navigation } = this.props;\n    const { closingRouteKeys, replacingRouteKeys } = this.state;\n\n    if (\n      closingRouteKeys.some((key) => key === route.key) &&\n      replacingRouteKeys.every((key) => key !== route.key) &&\n      state.routeNames.includes(route.name) &&\n      !state.routes.some((r) => r.key === route.key)\n    ) {\n      // If route isn't present in current state, but was closing, assume that a close animation was cancelled\n      // So we need to add this route back to the state\n      navigation.navigate(route);\n    } else {\n      this.setState((state) => ({\n        routes: state.replacingRouteKeys.length\n          ? state.routes.filter(\n              (r) => !state.replacingRouteKeys.includes(r.key)\n            )\n          : state.routes,\n        openingRouteKeys: state.openingRouteKeys.filter(\n          (key) => key !== route.key\n        ),\n        closingRouteKeys: state.closingRouteKeys.filter(\n          (key) => key !== route.key\n        ),\n        replacingRouteKeys: [],\n      }));\n    }\n  };\n\n  private handleCloseRoute = ({ route }: { route: Route<string> }) => {\n    const { state, navigation } = this.props;\n\n    if (state.routes.some((r) => r.key === route.key)) {\n      // If a route exists in state, trigger a pop\n      // This will happen in when the route was closed from the card component\n      // e.g. When the close animation triggered from a gesture ends\n      navigation.dispatch({\n        ...StackActions.pop(),\n        source: route.key,\n        target: state.key,\n      });\n    } else {\n      // We need to clean up any state tracking the route and pop it immediately\n      this.setState((state) => ({\n        routes: state.routes.filter((r) => r.key !== route.key),\n        openingRouteKeys: state.openingRouteKeys.filter(\n          (key) => key !== route.key\n        ),\n        closingRouteKeys: state.closingRouteKeys.filter(\n          (key) => key !== route.key\n        ),\n      }));\n    }\n  };\n\n  private handleTransitionStart = (\n    { route }: { route: Route<string> },\n    closing: boolean\n  ) =>\n    this.props.navigation.emit({\n      type: 'transitionStart',\n      data: { closing },\n      target: route.key,\n    });\n\n  private handleTransitionEnd = (\n    { route }: { route: Route<string> },\n    closing: boolean\n  ) =>\n    this.props.navigation.emit({\n      type: 'transitionEnd',\n      data: { closing },\n      target: route.key,\n    });\n\n  private handleGestureStart = ({ route }: { route: Route<string> }) => {\n    this.props.navigation.emit({\n      type: 'gestureStart',\n      target: route.key,\n    });\n  };\n\n  private handleGestureEnd = ({ route }: { route: Route<string> }) => {\n    this.props.navigation.emit({\n      type: 'gestureEnd',\n      target: route.key,\n    });\n  };\n\n  private handleGestureCancel = ({ route }: { route: Route<string> }) => {\n    this.props.navigation.emit({\n      type: 'gestureCancel',\n      target: route.key,\n    });\n  };\n\n  render() {\n    const {\n      state,\n      navigation,\n      keyboardHandlingEnabled,\n      mode = 'card',\n      headerMode = mode === 'card' && Platform.OS === 'ios'\n        ? 'float'\n        : 'screen',\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      descriptors: _,\n      ...rest\n    } = this.props;\n\n    const {\n      routes,\n      descriptors,\n      openingRouteKeys,\n      closingRouteKeys,\n    } = this.state;\n\n    return (\n      <NavigationHelpersContext.Provider value={navigation}>\n        <GestureHandlerWrapper style={styles.container}>\n          <SafeAreaProviderCompat>\n            <SafeAreaConsumer>\n              {(insets) => (\n                <KeyboardManager enabled={keyboardHandlingEnabled !== false}>\n                  {(props) => (\n                    <HeaderShownContext.Consumer>\n                      {(isParentHeaderShown) => (\n                        <CardStack\n                          mode={mode}\n                          insets={insets as EdgeInsets}\n                          isParentHeaderShown={isParentHeaderShown}\n                          getPreviousRoute={this.getPreviousRoute}\n                          getGesturesEnabled={this.getGesturesEnabled}\n                          routes={routes}\n                          openingRouteKeys={openingRouteKeys}\n                          closingRouteKeys={closingRouteKeys}\n                          onOpenRoute={this.handleOpenRoute}\n                          onCloseRoute={this.handleCloseRoute}\n                          onTransitionStart={this.handleTransitionStart}\n                          onTransitionEnd={this.handleTransitionEnd}\n                          renderHeader={this.renderHeader}\n                          renderScene={this.renderScene}\n                          headerMode={headerMode}\n                          state={state}\n                          descriptors={descriptors}\n                          onGestureStart={this.handleGestureStart}\n                          onGestureEnd={this.handleGestureEnd}\n                          onGestureCancel={this.handleGestureCancel}\n                          {...rest}\n                          {...props}\n                        />\n                      )}\n                    </HeaderShownContext.Consumer>\n                  )}\n                </KeyboardManager>\n              )}\n            </SafeAreaConsumer>\n          </SafeAreaProviderCompat>\n        </GestureHandlerWrapper>\n      </NavigationHelpersContext.Provider>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n});\n","import * as React from 'react';\nimport { Platform } from 'react-native';\nimport {\n  useNavigationBuilder,\n  createNavigatorFactory,\n  DefaultNavigatorOptions,\n  EventArg,\n  StackRouter,\n  StackRouterOptions,\n  StackNavigationState,\n  StackActions,\n  ParamListBase,\n  StackActionHelpers,\n} from '@react-navigation/native';\nimport StackView from '../views/Stack/StackView';\nimport type {\n  StackNavigationConfig,\n  StackNavigationOptions,\n  StackNavigationEventMap,\n} from '../types';\n\ntype Props = DefaultNavigatorOptions<StackNavigationOptions> &\n  StackRouterOptions &\n  StackNavigationConfig;\n\nfunction StackNavigator({\n  initialRouteName,\n  children,\n  screenOptions,\n  ...rest\n}: Props) {\n  const defaultOptions = {\n    gestureEnabled: Platform.OS === 'ios',\n    animationEnabled:\n      Platform.OS !== 'web' &&\n      Platform.OS !== 'windows' &&\n      Platform.OS !== 'macos',\n  };\n\n  const { state, descriptors, navigation } = useNavigationBuilder<\n    StackNavigationState<ParamListBase>,\n    StackRouterOptions,\n    StackActionHelpers<ParamListBase>,\n    StackNavigationOptions,\n    StackNavigationEventMap\n  >(StackRouter, {\n    initialRouteName,\n    children,\n    screenOptions:\n      typeof screenOptions === 'function'\n        ? (...args) => ({\n            ...defaultOptions,\n            ...screenOptions(...args),\n          })\n        : {\n            ...defaultOptions,\n            ...screenOptions,\n          },\n  });\n\n  React.useEffect(\n    () =>\n      navigation.addListener?.('tabPress', (e) => {\n        const isFocused = navigation.isFocused();\n\n        // Run the operation in the next frame so we're sure all listeners have been run\n        // This is necessary to know if preventDefault() has been called\n        requestAnimationFrame(() => {\n          if (\n            state.index > 0 &&\n            isFocused &&\n            !(e as EventArg<'tabPress', true>).defaultPrevented\n          ) {\n            // When user taps on already focused tab and we're inside the tab,\n            // reset the stack to replicate native behaviour\n            navigation.dispatch({\n              ...StackActions.popToTop(),\n              target: state.key,\n            });\n          }\n        });\n      }),\n    [navigation, state.index, state.key]\n  );\n\n  return (\n    <StackView\n      {...rest}\n      state={state}\n      descriptors={descriptors}\n      navigation={navigation}\n    />\n  );\n}\n\nexport default createNavigatorFactory<\n  StackNavigationState<ParamListBase>,\n  StackNavigationOptions,\n  StackNavigationEventMap,\n  typeof StackNavigator\n>(StackNavigator);\n"],"sourceRoot":""}